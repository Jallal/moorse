{"ast":null,"code":"import { warn } from '../log.js';\nimport { createStringifyContext } from '../stringify/stringify.js';\nimport { isAlias, isSeq, isScalar, isMap, isNode } from './Node.js';\nimport { Scalar } from './Scalar.js';\nimport { toJS } from './toJS.js';\nconst MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, _ref) {\n  let {\n    key,\n    value\n  } = _ref;\n  if (ctx?.doc.schema.merge && isMergeKey(key)) {\n    value = isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (isSeq(value)) for (const it of value.items) mergeToJSMap(ctx, map, it);else if (Array.isArray(value)) for (const it of value) mergeToJSMap(ctx, map, it);else mergeToJSMap(ctx, map, value);\n  } else {\n    const jsKey = toJS(key, '', ctx);\n    if (map instanceof Map) {\n      map.set(jsKey, toJS(value, jsKey, ctx));\n    } else if (map instanceof Set) {\n      map.add(jsKey);\n    } else {\n      const stringKey = stringifyKey(key, jsKey, ctx);\n      const jsValue = toJS(value, stringKey, ctx);\n      if (stringKey in map) Object.defineProperty(map, stringKey, {\n        value: jsValue,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });else map[stringKey] = jsValue;\n    }\n  }\n  return map;\n}\nconst isMergeKey = key => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nfunction mergeToJSMap(ctx, map, value) {\n  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n  if (!isMap(source)) throw new Error('Merge sources must be maps or map aliases');\n  const srcMap = source.toJSON(null, ctx, Map);\n  for (const [key, value] of srcMap) {\n    if (map instanceof Map) {\n      if (!map.has(key)) map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n      Object.defineProperty(map, key, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n  return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (isNode(key) && ctx && ctx.doc) {\n    const strCtx = createStringifyContext(ctx.doc, {});\n    strCtx.anchors = new Set();\n    for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);\n    strCtx.inFlow = true;\n    strCtx.inStringifyKey = true;\n    const strKey = key.toString(strCtx);\n    if (!ctx.mapKeyWarned) {\n      let jsonStr = JSON.stringify(strKey);\n      if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '...\"';\n      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n      ctx.mapKeyWarned = true;\n    }\n    return strKey;\n  }\n  return JSON.stringify(jsKey);\n}\nexport { addPairToJSMap };","map":{"version":3,"names":["warn","createStringifyContext","isAlias","isSeq","isScalar","isMap","isNode","Scalar","toJS","MERGE_KEY","addPairToJSMap","ctx","map","key","value","doc","schema","merge","isMergeKey","resolve","it","items","mergeToJSMap","Array","isArray","jsKey","Map","set","Set","add","stringKey","stringifyKey","jsValue","Object","defineProperty","writable","enumerable","configurable","type","PLAIN","source","Error","srcMap","toJSON","has","prototype","hasOwnProperty","call","String","strCtx","anchors","node","keys","anchor","inFlow","inStringifyKey","strKey","toString","mapKeyWarned","jsonStr","JSON","stringify","length","substring","options","logLevel"],"sources":["/workspaces/moorse/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"],"sourcesContent":["import { warn } from '../log.js';\nimport { createStringifyContext } from '../stringify/stringify.js';\nimport { isAlias, isSeq, isScalar, isMap, isNode } from './Node.js';\nimport { Scalar } from './Scalar.js';\nimport { toJS } from './toJS.js';\n\nconst MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (ctx?.doc.schema.merge && isMergeKey(key)) {\n        value = isAlias(value) ? value.resolve(ctx.doc) : value;\n        if (isSeq(value))\n            for (const it of value.items)\n                mergeToJSMap(ctx, map, it);\n        else if (Array.isArray(value))\n            for (const it of value)\n                mergeToJSMap(ctx, map, it);\n        else\n            mergeToJSMap(ctx, map, value);\n    }\n    else {\n        const jsKey = toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nconst isMergeKey = (key) => key === MERGE_KEY ||\n    (isScalar(key) &&\n        key.value === MERGE_KEY &&\n        (!key.type || key.type === Scalar.PLAIN));\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nfunction mergeToJSMap(ctx, map, value) {\n    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (isNode(key) && ctx && ctx.doc) {\n        const strCtx = createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexport { addPairToJSMap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}