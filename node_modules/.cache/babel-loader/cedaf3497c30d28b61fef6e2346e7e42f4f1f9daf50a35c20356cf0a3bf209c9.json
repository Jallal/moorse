{"ast":null,"code":"import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\nfunction includesToken(list, type) {\n  for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;\n  return false;\n}\nfunction findNonEmptyIndex(list) {\n  for (let i = 0; i < list.length; ++i) {\n    switch (list[i].type) {\n      case 'space':\n      case 'comment':\n      case 'newline':\n        break;\n      default:\n        return i;\n    }\n  }\n  return -1;\n}\nfunction isFlowToken(token) {\n  switch (token?.type) {\n    case 'alias':\n    case 'scalar':\n    case 'single-quoted-scalar':\n    case 'double-quoted-scalar':\n    case 'flow-collection':\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getPrevProps(parent) {\n  switch (parent.type) {\n    case 'document':\n      return parent.start;\n    case 'block-map':\n      {\n        const it = parent.items[parent.items.length - 1];\n        return it.sep ?? it.start;\n      }\n    case 'block-seq':\n      return parent.items[parent.items.length - 1].start;\n    /* istanbul ignore next should not happen */\n    default:\n      return [];\n  }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n  if (prev.length === 0) return [];\n  let i = prev.length;\n  loop: while (--i >= 0) {\n    switch (prev[i].type) {\n      case 'doc-start':\n      case 'explicit-key-ind':\n      case 'map-value-ind':\n      case 'seq-item-ind':\n      case 'newline':\n        break loop;\n    }\n  }\n  while (prev[++i]?.type === 'space') {\n    /* loop */\n  }\n  return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n  if (fc.start.type === 'flow-seq-start') {\n    for (const it of fc.items) {\n      if (it.sep && !it.value && !includesToken(it.start, 'explicit-key-ind') && !includesToken(it.sep, 'map-value-ind')) {\n        if (it.key) it.value = it.key;\n        delete it.key;\n        if (isFlowToken(it.value)) {\n          if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);else it.value.end = it.sep;\n        } else Array.prototype.push.apply(it.start, it.sep);\n        delete it.sep;\n      }\n    }\n  }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n  /**\n   * @param onNewLine - If defined, called separately with the start position of\n   *   each new line (in `parse()`, including the start of input).\n   */\n  constructor(onNewLine) {\n    /** If true, space and sequence indicators count as indentation */\n    this.atNewLine = true;\n    /** If true, next token is a scalar value */\n    this.atScalar = false;\n    /** Current indentation level */\n    this.indent = 0;\n    /** Current offset since the start of parsing */\n    this.offset = 0;\n    /** On the same line with a block map key */\n    this.onKeyLine = false;\n    /** Top indicates the node that's currently being built */\n    this.stack = [];\n    /** The source of the current token, set in parse() */\n    this.source = '';\n    /** The type of the current token, set in parse() */\n    this.type = '';\n    // Must be defined after `next()`\n    this.lexer = new Lexer();\n    this.onNewLine = onNewLine;\n  }\n  /**\n   * Parse `source` as a YAML stream.\n   * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n   *\n   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n   *\n   * @returns A generator of tokens representing each directive, document, and other structure.\n   */\n  parse(source) {\n    var _this = this;\n    let incomplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return function* () {\n      if (_this.onNewLine && _this.offset === 0) _this.onNewLine(0);\n      for (const lexeme of _this.lexer.lex(source, incomplete)) yield* _this.next(lexeme);\n      if (!incomplete) yield* _this.end();\n    }();\n  }\n  /**\n   * Advance the parser by the `source` of one lexical token.\n   */\n  *next(source) {\n    this.source = source;\n    if (this.atScalar) {\n      this.atScalar = false;\n      yield* this.step();\n      this.offset += source.length;\n      return;\n    }\n    const type = tokenType(source);\n    if (!type) {\n      const message = `Not a YAML token: ${source}`;\n      yield* this.pop({\n        type: 'error',\n        offset: this.offset,\n        message,\n        source\n      });\n      this.offset += source.length;\n    } else if (type === 'scalar') {\n      this.atNewLine = false;\n      this.atScalar = true;\n      this.type = 'scalar';\n    } else {\n      this.type = type;\n      yield* this.step();\n      switch (type) {\n        case 'newline':\n          this.atNewLine = true;\n          this.indent = 0;\n          if (this.onNewLine) this.onNewLine(this.offset + source.length);\n          break;\n        case 'space':\n          if (this.atNewLine && source[0] === ' ') this.indent += source.length;\n          break;\n        case 'explicit-key-ind':\n        case 'map-value-ind':\n        case 'seq-item-ind':\n          if (this.atNewLine) this.indent += source.length;\n          break;\n        case 'doc-mode':\n        case 'flow-error-end':\n          return;\n        default:\n          this.atNewLine = false;\n      }\n      this.offset += source.length;\n    }\n  }\n  /** Call at end of input to push out any remaining constructions */\n  *end() {\n    while (this.stack.length > 0) yield* this.pop();\n  }\n  get sourceToken() {\n    const st = {\n      type: this.type,\n      offset: this.offset,\n      indent: this.indent,\n      source: this.source\n    };\n    return st;\n  }\n  *step() {\n    const top = this.peek(1);\n    if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n      while (this.stack.length > 0) yield* this.pop();\n      this.stack.push({\n        type: 'doc-end',\n        offset: this.offset,\n        source: this.source\n      });\n      return;\n    }\n    if (!top) return yield* this.stream();\n    switch (top.type) {\n      case 'document':\n        return yield* this.document(top);\n      case 'alias':\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return yield* this.scalar(top);\n      case 'block-scalar':\n        return yield* this.blockScalar(top);\n      case 'block-map':\n        return yield* this.blockMap(top);\n      case 'block-seq':\n        return yield* this.blockSequence(top);\n      case 'flow-collection':\n        return yield* this.flowCollection(top);\n      case 'doc-end':\n        return yield* this.documentEnd(top);\n    }\n    /* istanbul ignore next should not happen */\n    yield* this.pop();\n  }\n  peek(n) {\n    return this.stack[this.stack.length - n];\n  }\n  *pop(error) {\n    const token = error ?? this.stack.pop();\n    /* istanbul ignore if should not happen */\n    if (!token) {\n      const message = 'Tried to pop an empty stack';\n      yield {\n        type: 'error',\n        offset: this.offset,\n        source: '',\n        message\n      };\n    } else if (this.stack.length === 0) {\n      yield token;\n    } else {\n      const top = this.peek(1);\n      if (token.type === 'block-scalar') {\n        // Block scalars use their parent rather than header indent\n        token.indent = 'indent' in top ? top.indent : 0;\n      } else if (token.type === 'flow-collection' && top.type === 'document') {\n        // Ignore all indent for top-level flow collections\n        token.indent = 0;\n      }\n      if (token.type === 'flow-collection') fixFlowSeqItems(token);\n      switch (top.type) {\n        case 'document':\n          top.value = token;\n          break;\n        case 'block-scalar':\n          top.props.push(token); // error\n          break;\n        case 'block-map':\n          {\n            const it = top.items[top.items.length - 1];\n            if (it.value) {\n              top.items.push({\n                start: [],\n                key: token,\n                sep: []\n              });\n              this.onKeyLine = true;\n              return;\n            } else if (it.sep) {\n              it.value = token;\n            } else {\n              Object.assign(it, {\n                key: token,\n                sep: []\n              });\n              this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n              return;\n            }\n            break;\n          }\n        case 'block-seq':\n          {\n            const it = top.items[top.items.length - 1];\n            if (it.value) top.items.push({\n              start: [],\n              value: token\n            });else it.value = token;\n            break;\n          }\n        case 'flow-collection':\n          {\n            const it = top.items[top.items.length - 1];\n            if (!it || it.value) top.items.push({\n              start: [],\n              key: token,\n              sep: []\n            });else if (it.sep) it.value = token;else Object.assign(it, {\n              key: token,\n              sep: []\n            });\n            return;\n          }\n        /* istanbul ignore next should not happen */\n        default:\n          yield* this.pop();\n          yield* this.pop(token);\n      }\n      if ((top.type === 'document' || top.type === 'block-map' || top.type === 'block-seq') && (token.type === 'block-map' || token.type === 'block-seq')) {\n        const last = token.items[token.items.length - 1];\n        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n          if (top.type === 'document') top.end = last.start;else top.items.push({\n            start: last.start\n          });\n          token.items.splice(-1, 1);\n        }\n      }\n    }\n  }\n  *stream() {\n    switch (this.type) {\n      case 'directive-line':\n        yield {\n          type: 'directive',\n          offset: this.offset,\n          source: this.source\n        };\n        return;\n      case 'byte-order-mark':\n      case 'space':\n      case 'comment':\n      case 'newline':\n        yield this.sourceToken;\n        return;\n      case 'doc-mode':\n      case 'doc-start':\n        {\n          const doc = {\n            type: 'document',\n            offset: this.offset,\n            start: []\n          };\n          if (this.type === 'doc-start') doc.start.push(this.sourceToken);\n          this.stack.push(doc);\n          return;\n        }\n    }\n    yield {\n      type: 'error',\n      offset: this.offset,\n      message: `Unexpected ${this.type} token in YAML stream`,\n      source: this.source\n    };\n  }\n  *document(doc) {\n    if (doc.value) return yield* this.lineEnd(doc);\n    switch (this.type) {\n      case 'doc-start':\n        {\n          if (findNonEmptyIndex(doc.start) !== -1) {\n            yield* this.pop();\n            yield* this.step();\n          } else doc.start.push(this.sourceToken);\n          return;\n        }\n      case 'anchor':\n      case 'tag':\n      case 'space':\n      case 'comment':\n      case 'newline':\n        doc.start.push(this.sourceToken);\n        return;\n    }\n    const bv = this.startBlockValue(doc);\n    if (bv) this.stack.push(bv);else {\n      yield {\n        type: 'error',\n        offset: this.offset,\n        message: `Unexpected ${this.type} token in YAML document`,\n        source: this.source\n      };\n    }\n  }\n  *scalar(scalar) {\n    if (this.type === 'map-value-ind') {\n      const prev = getPrevProps(this.peek(2));\n      const start = getFirstKeyStartProps(prev);\n      let sep;\n      if (scalar.end) {\n        sep = scalar.end;\n        sep.push(this.sourceToken);\n        delete scalar.end;\n      } else sep = [this.sourceToken];\n      const map = {\n        type: 'block-map',\n        offset: scalar.offset,\n        indent: scalar.indent,\n        items: [{\n          start,\n          key: scalar,\n          sep\n        }]\n      };\n      this.onKeyLine = true;\n      this.stack[this.stack.length - 1] = map;\n    } else yield* this.lineEnd(scalar);\n  }\n  *blockScalar(scalar) {\n    switch (this.type) {\n      case 'space':\n      case 'comment':\n      case 'newline':\n        scalar.props.push(this.sourceToken);\n        return;\n      case 'scalar':\n        scalar.source = this.source;\n        // block-scalar source includes trailing newline\n        this.atNewLine = true;\n        this.indent = 0;\n        if (this.onNewLine) {\n          let nl = this.source.indexOf('\\n') + 1;\n          while (nl !== 0) {\n            this.onNewLine(this.offset + nl);\n            nl = this.source.indexOf('\\n', nl) + 1;\n          }\n        }\n        yield* this.pop();\n        break;\n      /* istanbul ignore next should not happen */\n      default:\n        yield* this.pop();\n        yield* this.step();\n    }\n  }\n  *blockMap(map) {\n    const it = map.items[map.items.length - 1];\n    // it.sep is true-ish if pair already has key or : separator\n    switch (this.type) {\n      case 'newline':\n        this.onKeyLine = false;\n        if (it.value) {\n          const end = 'end' in it.value ? it.value.end : undefined;\n          const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n          if (last?.type === 'comment') end?.push(this.sourceToken);else map.items.push({\n            start: [this.sourceToken]\n          });\n        } else if (it.sep) {\n          it.sep.push(this.sourceToken);\n        } else {\n          it.start.push(this.sourceToken);\n        }\n        return;\n      case 'space':\n      case 'comment':\n        if (it.value) {\n          map.items.push({\n            start: [this.sourceToken]\n          });\n        } else if (it.sep) {\n          it.sep.push(this.sourceToken);\n        } else {\n          if (this.atIndentedComment(it.start, map.indent)) {\n            const prev = map.items[map.items.length - 2];\n            const end = prev?.value?.end;\n            if (Array.isArray(end)) {\n              Array.prototype.push.apply(end, it.start);\n              end.push(this.sourceToken);\n              map.items.pop();\n              return;\n            }\n          }\n          it.start.push(this.sourceToken);\n        }\n        return;\n    }\n    if (this.indent >= map.indent) {\n      const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n      // For empty nodes, assign newline-separated not indented empty tokens to following node\n      let start = [];\n      if (atNextItem && it.sep && !it.value) {\n        const nl = [];\n        for (let i = 0; i < it.sep.length; ++i) {\n          const st = it.sep[i];\n          switch (st.type) {\n            case 'newline':\n              nl.push(i);\n              break;\n            case 'space':\n              break;\n            case 'comment':\n              if (st.indent > map.indent) nl.length = 0;\n              break;\n            default:\n              nl.length = 0;\n          }\n        }\n        if (nl.length >= 2) start = it.sep.splice(nl[1]);\n      }\n      switch (this.type) {\n        case 'anchor':\n        case 'tag':\n          if (atNextItem || it.value) {\n            start.push(this.sourceToken);\n            map.items.push({\n              start\n            });\n            this.onKeyLine = true;\n          } else if (it.sep) {\n            it.sep.push(this.sourceToken);\n          } else {\n            it.start.push(this.sourceToken);\n          }\n          return;\n        case 'explicit-key-ind':\n          if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n            it.start.push(this.sourceToken);\n          } else if (atNextItem || it.value) {\n            start.push(this.sourceToken);\n            map.items.push({\n              start\n            });\n          } else {\n            this.stack.push({\n              type: 'block-map',\n              offset: this.offset,\n              indent: this.indent,\n              items: [{\n                start: [this.sourceToken]\n              }]\n            });\n          }\n          this.onKeyLine = true;\n          return;\n        case 'map-value-ind':\n          if (includesToken(it.start, 'explicit-key-ind')) {\n            if (!it.sep) {\n              if (includesToken(it.start, 'newline')) {\n                Object.assign(it, {\n                  key: null,\n                  sep: [this.sourceToken]\n                });\n              } else {\n                const start = getFirstKeyStartProps(it.start);\n                this.stack.push({\n                  type: 'block-map',\n                  offset: this.offset,\n                  indent: this.indent,\n                  items: [{\n                    start,\n                    key: null,\n                    sep: [this.sourceToken]\n                  }]\n                });\n              }\n            } else if (it.value) {\n              map.items.push({\n                start: [],\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (includesToken(it.sep, 'map-value-ind')) {\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start,\n                  key: null,\n                  sep: [this.sourceToken]\n                }]\n              });\n            } else if (isFlowToken(it.key) && !includesToken(it.sep, 'newline')) {\n              const start = getFirstKeyStartProps(it.start);\n              const key = it.key;\n              const sep = it.sep;\n              sep.push(this.sourceToken);\n              // @ts-expect-error type guard is wrong here\n              delete it.key, delete it.sep;\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start,\n                  key,\n                  sep\n                }]\n              });\n            } else if (start.length > 0) {\n              // Not actually at next item\n              it.sep = it.sep.concat(start, this.sourceToken);\n            } else {\n              it.sep.push(this.sourceToken);\n            }\n          } else {\n            if (!it.sep) {\n              Object.assign(it, {\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (it.value || atNextItem) {\n              map.items.push({\n                start,\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (includesToken(it.sep, 'map-value-ind')) {\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start: [],\n                  key: null,\n                  sep: [this.sourceToken]\n                }]\n              });\n            } else {\n              it.sep.push(this.sourceToken);\n            }\n          }\n          this.onKeyLine = true;\n          return;\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          {\n            const fs = this.flowScalar(this.type);\n            if (atNextItem || it.value) {\n              map.items.push({\n                start,\n                key: fs,\n                sep: []\n              });\n              this.onKeyLine = true;\n            } else if (it.sep) {\n              this.stack.push(fs);\n            } else {\n              Object.assign(it, {\n                key: fs,\n                sep: []\n              });\n              this.onKeyLine = true;\n            }\n            return;\n          }\n        default:\n          {\n            const bv = this.startBlockValue(map);\n            if (bv) {\n              if (atNextItem && bv.type !== 'block-seq' && includesToken(it.start, 'explicit-key-ind')) {\n                map.items.push({\n                  start\n                });\n              }\n              this.stack.push(bv);\n              return;\n            }\n          }\n      }\n    }\n    yield* this.pop();\n    yield* this.step();\n  }\n  *blockSequence(seq) {\n    const it = seq.items[seq.items.length - 1];\n    switch (this.type) {\n      case 'newline':\n        if (it.value) {\n          const end = 'end' in it.value ? it.value.end : undefined;\n          const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n          if (last?.type === 'comment') end?.push(this.sourceToken);else seq.items.push({\n            start: [this.sourceToken]\n          });\n        } else it.start.push(this.sourceToken);\n        return;\n      case 'space':\n      case 'comment':\n        if (it.value) seq.items.push({\n          start: [this.sourceToken]\n        });else {\n          if (this.atIndentedComment(it.start, seq.indent)) {\n            const prev = seq.items[seq.items.length - 2];\n            const end = prev?.value?.end;\n            if (Array.isArray(end)) {\n              Array.prototype.push.apply(end, it.start);\n              end.push(this.sourceToken);\n              seq.items.pop();\n              return;\n            }\n          }\n          it.start.push(this.sourceToken);\n        }\n        return;\n      case 'anchor':\n      case 'tag':\n        if (it.value || this.indent <= seq.indent) break;\n        it.start.push(this.sourceToken);\n        return;\n      case 'seq-item-ind':\n        if (this.indent !== seq.indent) break;\n        if (it.value || includesToken(it.start, 'seq-item-ind')) seq.items.push({\n          start: [this.sourceToken]\n        });else it.start.push(this.sourceToken);\n        return;\n    }\n    if (this.indent > seq.indent) {\n      const bv = this.startBlockValue(seq);\n      if (bv) {\n        this.stack.push(bv);\n        return;\n      }\n    }\n    yield* this.pop();\n    yield* this.step();\n  }\n  *flowCollection(fc) {\n    const it = fc.items[fc.items.length - 1];\n    if (this.type === 'flow-error-end') {\n      let top;\n      do {\n        yield* this.pop();\n        top = this.peek(1);\n      } while (top && top.type === 'flow-collection');\n    } else if (fc.end.length === 0) {\n      switch (this.type) {\n        case 'comma':\n        case 'explicit-key-ind':\n          if (!it || it.sep) fc.items.push({\n            start: [this.sourceToken]\n          });else it.start.push(this.sourceToken);\n          return;\n        case 'map-value-ind':\n          if (!it || it.value) fc.items.push({\n            start: [],\n            key: null,\n            sep: [this.sourceToken]\n          });else if (it.sep) it.sep.push(this.sourceToken);else Object.assign(it, {\n            key: null,\n            sep: [this.sourceToken]\n          });\n          return;\n        case 'space':\n        case 'comment':\n        case 'newline':\n        case 'anchor':\n        case 'tag':\n          if (!it || it.value) fc.items.push({\n            start: [this.sourceToken]\n          });else if (it.sep) it.sep.push(this.sourceToken);else it.start.push(this.sourceToken);\n          return;\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          {\n            const fs = this.flowScalar(this.type);\n            if (!it || it.value) fc.items.push({\n              start: [],\n              key: fs,\n              sep: []\n            });else if (it.sep) this.stack.push(fs);else Object.assign(it, {\n              key: fs,\n              sep: []\n            });\n            return;\n          }\n        case 'flow-map-end':\n        case 'flow-seq-end':\n          fc.end.push(this.sourceToken);\n          return;\n      }\n      const bv = this.startBlockValue(fc);\n      /* istanbul ignore else should not happen */\n      if (bv) this.stack.push(bv);else {\n        yield* this.pop();\n        yield* this.step();\n      }\n    } else {\n      const parent = this.peek(2);\n      if (parent.type === 'block-map' && (this.type === 'map-value-ind' && parent.indent === fc.indent || this.type === 'newline' && !parent.items[parent.items.length - 1].sep)) {\n        yield* this.pop();\n        yield* this.step();\n      } else if (this.type === 'map-value-ind' && parent.type !== 'flow-collection') {\n        const prev = getPrevProps(parent);\n        const start = getFirstKeyStartProps(prev);\n        fixFlowSeqItems(fc);\n        const sep = fc.end.splice(1, fc.end.length);\n        sep.push(this.sourceToken);\n        const map = {\n          type: 'block-map',\n          offset: fc.offset,\n          indent: fc.indent,\n          items: [{\n            start,\n            key: fc,\n            sep\n          }]\n        };\n        this.onKeyLine = true;\n        this.stack[this.stack.length - 1] = map;\n      } else {\n        yield* this.lineEnd(fc);\n      }\n    }\n  }\n  flowScalar(type) {\n    if (this.onNewLine) {\n      let nl = this.source.indexOf('\\n') + 1;\n      while (nl !== 0) {\n        this.onNewLine(this.offset + nl);\n        nl = this.source.indexOf('\\n', nl) + 1;\n      }\n    }\n    return {\n      type,\n      offset: this.offset,\n      indent: this.indent,\n      source: this.source\n    };\n  }\n  startBlockValue(parent) {\n    switch (this.type) {\n      case 'alias':\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return this.flowScalar(this.type);\n      case 'block-scalar-header':\n        return {\n          type: 'block-scalar',\n          offset: this.offset,\n          indent: this.indent,\n          props: [this.sourceToken],\n          source: ''\n        };\n      case 'flow-map-start':\n      case 'flow-seq-start':\n        return {\n          type: 'flow-collection',\n          offset: this.offset,\n          indent: this.indent,\n          start: this.sourceToken,\n          items: [],\n          end: []\n        };\n      case 'seq-item-ind':\n        return {\n          type: 'block-seq',\n          offset: this.offset,\n          indent: this.indent,\n          items: [{\n            start: [this.sourceToken]\n          }]\n        };\n      case 'explicit-key-ind':\n        {\n          this.onKeyLine = true;\n          const prev = getPrevProps(parent);\n          const start = getFirstKeyStartProps(prev);\n          start.push(this.sourceToken);\n          return {\n            type: 'block-map',\n            offset: this.offset,\n            indent: this.indent,\n            items: [{\n              start\n            }]\n          };\n        }\n      case 'map-value-ind':\n        {\n          this.onKeyLine = true;\n          const prev = getPrevProps(parent);\n          const start = getFirstKeyStartProps(prev);\n          return {\n            type: 'block-map',\n            offset: this.offset,\n            indent: this.indent,\n            items: [{\n              start,\n              key: null,\n              sep: [this.sourceToken]\n            }]\n          };\n        }\n    }\n    return null;\n  }\n  atIndentedComment(start, indent) {\n    if (this.type !== 'comment') return false;\n    if (this.indent <= indent) return false;\n    return start.every(st => st.type === 'newline' || st.type === 'space');\n  }\n  *documentEnd(docEnd) {\n    if (this.type !== 'doc-mode') {\n      if (docEnd.end) docEnd.end.push(this.sourceToken);else docEnd.end = [this.sourceToken];\n      if (this.type === 'newline') yield* this.pop();\n    }\n  }\n  *lineEnd(token) {\n    switch (this.type) {\n      case 'comma':\n      case 'doc-start':\n      case 'doc-end':\n      case 'flow-seq-end':\n      case 'flow-map-end':\n      case 'map-value-ind':\n        yield* this.pop();\n        yield* this.step();\n        break;\n      case 'newline':\n        this.onKeyLine = false;\n      // fallthrough\n      case 'space':\n      case 'comment':\n      default:\n        // all other values are errors\n        if (token.end) token.end.push(this.sourceToken);else token.end = [this.sourceToken];\n        if (this.type === 'newline') yield* this.pop();\n    }\n  }\n}\nexport { Parser };","map":{"version":3,"names":["tokenType","Lexer","includesToken","list","type","i","length","findNonEmptyIndex","isFlowToken","token","getPrevProps","parent","start","it","items","sep","getFirstKeyStartProps","prev","loop","splice","fixFlowSeqItems","fc","value","key","end","Array","prototype","push","apply","Parser","constructor","onNewLine","atNewLine","atScalar","indent","offset","onKeyLine","stack","source","lexer","parse","incomplete","lexeme","lex","next","step","message","pop","sourceToken","st","top","peek","stream","document","scalar","blockScalar","blockMap","blockSequence","flowCollection","documentEnd","n","error","props","Object","assign","last","every","doc","lineEnd","bv","startBlockValue","map","nl","indexOf","undefined","isArray","atIndentedComment","atNextItem","concat","fs","flowScalar","seq","docEnd"],"sources":["/workspaces/moorse/node_modules/yaml/browser/dist/parse/parser.js"],"sourcesContent":["import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n                        it.start.push(this.sourceToken);\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken] }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (includesToken(it.start, 'explicit-key-ind')) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key, delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atNextItem &&\n                            bv.type !== 'block-seq' &&\n                            includesToken(it.start, 'explicit-key-ind')) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,UAAU;AACpC,SAASC,KAAK,QAAQ,YAAY;AAElC,SAASC,aAAa,CAACC,IAAI,EAAEC,IAAI,EAAE;EAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAE,EAAED,CAAC,EAChC,IAAIF,IAAI,CAACE,CAAC,CAAC,CAACD,IAAI,KAAKA,IAAI,EACrB,OAAO,IAAI;EACnB,OAAO,KAAK;AAChB;AACA,SAASG,iBAAiB,CAACJ,IAAI,EAAE;EAC7B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACG,MAAM,EAAE,EAAED,CAAC,EAAE;IAClC,QAAQF,IAAI,CAACE,CAAC,CAAC,CAACD,IAAI;MAChB,KAAK,OAAO;MACZ,KAAK,SAAS;MACd,KAAK,SAAS;QACV;MACJ;QACI,OAAOC,CAAC;IAAC;EAErB;EACA,OAAO,CAAC,CAAC;AACb;AACA,SAASG,WAAW,CAACC,KAAK,EAAE;EACxB,QAAQA,KAAK,EAAEL,IAAI;IACf,KAAK,OAAO;IACZ,KAAK,QAAQ;IACb,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,iBAAiB;MAClB,OAAO,IAAI;IACf;MACI,OAAO,KAAK;EAAC;AAEzB;AACA,SAASM,YAAY,CAACC,MAAM,EAAE;EAC1B,QAAQA,MAAM,CAACP,IAAI;IACf,KAAK,UAAU;MACX,OAAOO,MAAM,CAACC,KAAK;IACvB,KAAK,WAAW;MAAE;QACd,MAAMC,EAAE,GAAGF,MAAM,CAACG,KAAK,CAACH,MAAM,CAACG,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;QAChD,OAAOO,EAAE,CAACE,GAAG,IAAIF,EAAE,CAACD,KAAK;MAC7B;IACA,KAAK,WAAW;MACZ,OAAOD,MAAM,CAACG,KAAK,CAACH,MAAM,CAACG,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC,CAACM,KAAK;IACtD;IACA;MACI,OAAO,EAAE;EAAC;AAEtB;AACA;AACA,SAASI,qBAAqB,CAACC,IAAI,EAAE;EACjC,IAAIA,IAAI,CAACX,MAAM,KAAK,CAAC,EACjB,OAAO,EAAE;EACb,IAAID,CAAC,GAAGY,IAAI,CAACX,MAAM;EACnBY,IAAI,EAAE,OAAO,EAAEb,CAAC,IAAI,CAAC,EAAE;IACnB,QAAQY,IAAI,CAACZ,CAAC,CAAC,CAACD,IAAI;MAChB,KAAK,WAAW;MAChB,KAAK,kBAAkB;MACvB,KAAK,eAAe;MACpB,KAAK,cAAc;MACnB,KAAK,SAAS;QACV,MAAMc,IAAI;IAAC;EAEvB;EACA,OAAOD,IAAI,CAAC,EAAEZ,CAAC,CAAC,EAAED,IAAI,KAAK,OAAO,EAAE;IAChC;EAAA;EAEJ,OAAOa,IAAI,CAACE,MAAM,CAACd,CAAC,EAAEY,IAAI,CAACX,MAAM,CAAC;AACtC;AACA,SAASc,eAAe,CAACC,EAAE,EAAE;EACzB,IAAIA,EAAE,CAACT,KAAK,CAACR,IAAI,KAAK,gBAAgB,EAAE;IACpC,KAAK,MAAMS,EAAE,IAAIQ,EAAE,CAACP,KAAK,EAAE;MACvB,IAAID,EAAE,CAACE,GAAG,IACN,CAACF,EAAE,CAACS,KAAK,IACT,CAACpB,aAAa,CAACW,EAAE,CAACD,KAAK,EAAE,kBAAkB,CAAC,IAC5C,CAACV,aAAa,CAACW,EAAE,CAACE,GAAG,EAAE,eAAe,CAAC,EAAE;QACzC,IAAIF,EAAE,CAACU,GAAG,EACNV,EAAE,CAACS,KAAK,GAAGT,EAAE,CAACU,GAAG;QACrB,OAAOV,EAAE,CAACU,GAAG;QACb,IAAIf,WAAW,CAACK,EAAE,CAACS,KAAK,CAAC,EAAE;UACvB,IAAIT,EAAE,CAACS,KAAK,CAACE,GAAG,EACZC,KAAK,CAACC,SAAS,CAACC,IAAI,CAACC,KAAK,CAACf,EAAE,CAACS,KAAK,CAACE,GAAG,EAAEX,EAAE,CAACE,GAAG,CAAC,CAAC,KAEjDF,EAAE,CAACS,KAAK,CAACE,GAAG,GAAGX,EAAE,CAACE,GAAG;QAC7B,CAAC,MAEGU,KAAK,CAACC,SAAS,CAACC,IAAI,CAACC,KAAK,CAACf,EAAE,CAACD,KAAK,EAAEC,EAAE,CAACE,GAAG,CAAC;QAChD,OAAOF,EAAE,CAACE,GAAG;MACjB;IACJ;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMc,MAAM,CAAC;EACT;AACJ;AACA;AACA;EACIC,WAAW,CAACC,SAAS,EAAE;IACnB;IACA,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB;IACA,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB;IACA,IAAI,CAACC,MAAM,GAAG,CAAC;IACf;IACA,IAAI,CAACC,MAAM,GAAG,CAAC;IACf;IACA,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB;IACA,IAAI,CAACC,KAAK,GAAG,EAAE;IACf;IACA,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB;IACA,IAAI,CAAClC,IAAI,GAAG,EAAE;IACd;IACA,IAAI,CAACmC,KAAK,GAAG,IAAItC,KAAK,EAAE;IACxB,IAAI,CAAC8B,SAAS,GAAGA,SAAS;EAC9B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACKS,KAAK,CAACF,MAAM;IAAA;IAAA,IAAEG,UAAU,uEAAG,KAAK;IAAA,oBAAE;MAC/B,IAAI,KAAI,CAACV,SAAS,IAAI,KAAI,CAACI,MAAM,KAAK,CAAC,EACnC,KAAI,CAACJ,SAAS,CAAC,CAAC,CAAC;MACrB,KAAK,MAAMW,MAAM,IAAI,KAAI,CAACH,KAAK,CAACI,GAAG,CAACL,MAAM,EAAEG,UAAU,CAAC,EACnD,OAAO,KAAI,CAACG,IAAI,CAACF,MAAM,CAAC;MAC5B,IAAI,CAACD,UAAU,EACX,OAAO,KAAI,CAACjB,GAAG,EAAE;IACzB,CAAC;EAAA;EACD;AACJ;AACA;EACI,CAACoB,IAAI,CAACN,MAAM,EAAE;IACV,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,IAAI,CAACL,QAAQ,EAAE;MACf,IAAI,CAACA,QAAQ,GAAG,KAAK;MACrB,OAAO,IAAI,CAACY,IAAI,EAAE;MAClB,IAAI,CAACV,MAAM,IAAIG,MAAM,CAAChC,MAAM;MAC5B;IACJ;IACA,MAAMF,IAAI,GAAGJ,SAAS,CAACsC,MAAM,CAAC;IAC9B,IAAI,CAAClC,IAAI,EAAE;MACP,MAAM0C,OAAO,GAAI,qBAAoBR,MAAO,EAAC;MAC7C,OAAO,IAAI,CAACS,GAAG,CAAC;QAAE3C,IAAI,EAAE,OAAO;QAAE+B,MAAM,EAAE,IAAI,CAACA,MAAM;QAAEW,OAAO;QAAER;MAAO,CAAC,CAAC;MACxE,IAAI,CAACH,MAAM,IAAIG,MAAM,CAAChC,MAAM;IAChC,CAAC,MACI,IAAIF,IAAI,KAAK,QAAQ,EAAE;MACxB,IAAI,CAAC4B,SAAS,GAAG,KAAK;MACtB,IAAI,CAACC,QAAQ,GAAG,IAAI;MACpB,IAAI,CAAC7B,IAAI,GAAG,QAAQ;IACxB,CAAC,MACI;MACD,IAAI,CAACA,IAAI,GAAGA,IAAI;MAChB,OAAO,IAAI,CAACyC,IAAI,EAAE;MAClB,QAAQzC,IAAI;QACR,KAAK,SAAS;UACV,IAAI,CAAC4B,SAAS,GAAG,IAAI;UACrB,IAAI,CAACE,MAAM,GAAG,CAAC;UACf,IAAI,IAAI,CAACH,SAAS,EACd,IAAI,CAACA,SAAS,CAAC,IAAI,CAACI,MAAM,GAAGG,MAAM,CAAChC,MAAM,CAAC;UAC/C;QACJ,KAAK,OAAO;UACR,IAAI,IAAI,CAAC0B,SAAS,IAAIM,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EACnC,IAAI,CAACJ,MAAM,IAAII,MAAM,CAAChC,MAAM;UAChC;QACJ,KAAK,kBAAkB;QACvB,KAAK,eAAe;QACpB,KAAK,cAAc;UACf,IAAI,IAAI,CAAC0B,SAAS,EACd,IAAI,CAACE,MAAM,IAAII,MAAM,CAAChC,MAAM;UAChC;QACJ,KAAK,UAAU;QACf,KAAK,gBAAgB;UACjB;QACJ;UACI,IAAI,CAAC0B,SAAS,GAAG,KAAK;MAAC;MAE/B,IAAI,CAACG,MAAM,IAAIG,MAAM,CAAChC,MAAM;IAChC;EACJ;EACA;EACA,CAACkB,GAAG,GAAG;IACH,OAAO,IAAI,CAACa,KAAK,CAAC/B,MAAM,GAAG,CAAC,EACxB,OAAO,IAAI,CAACyC,GAAG,EAAE;EACzB;EACA,IAAIC,WAAW,GAAG;IACd,MAAMC,EAAE,GAAG;MACP7C,IAAI,EAAE,IAAI,CAACA,IAAI;MACf+B,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBI,MAAM,EAAE,IAAI,CAACA;IACjB,CAAC;IACD,OAAOW,EAAE;EACb;EACA,CAACJ,IAAI,GAAG;IACJ,MAAMK,GAAG,GAAG,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;IACxB,IAAI,IAAI,CAAC/C,IAAI,KAAK,SAAS,KAAK,CAAC8C,GAAG,IAAIA,GAAG,CAAC9C,IAAI,KAAK,SAAS,CAAC,EAAE;MAC7D,OAAO,IAAI,CAACiC,KAAK,CAAC/B,MAAM,GAAG,CAAC,EACxB,OAAO,IAAI,CAACyC,GAAG,EAAE;MACrB,IAAI,CAACV,KAAK,CAACV,IAAI,CAAC;QACZvB,IAAI,EAAE,SAAS;QACf+B,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBG,MAAM,EAAE,IAAI,CAACA;MACjB,CAAC,CAAC;MACF;IACJ;IACA,IAAI,CAACY,GAAG,EACJ,OAAO,OAAO,IAAI,CAACE,MAAM,EAAE;IAC/B,QAAQF,GAAG,CAAC9C,IAAI;MACZ,KAAK,UAAU;QACX,OAAO,OAAO,IAAI,CAACiD,QAAQ,CAACH,GAAG,CAAC;MACpC,KAAK,OAAO;MACZ,KAAK,QAAQ;MACb,KAAK,sBAAsB;MAC3B,KAAK,sBAAsB;QACvB,OAAO,OAAO,IAAI,CAACI,MAAM,CAACJ,GAAG,CAAC;MAClC,KAAK,cAAc;QACf,OAAO,OAAO,IAAI,CAACK,WAAW,CAACL,GAAG,CAAC;MACvC,KAAK,WAAW;QACZ,OAAO,OAAO,IAAI,CAACM,QAAQ,CAACN,GAAG,CAAC;MACpC,KAAK,WAAW;QACZ,OAAO,OAAO,IAAI,CAACO,aAAa,CAACP,GAAG,CAAC;MACzC,KAAK,iBAAiB;QAClB,OAAO,OAAO,IAAI,CAACQ,cAAc,CAACR,GAAG,CAAC;MAC1C,KAAK,SAAS;QACV,OAAO,OAAO,IAAI,CAACS,WAAW,CAACT,GAAG,CAAC;IAAC;IAE5C;IACA,OAAO,IAAI,CAACH,GAAG,EAAE;EACrB;EACAI,IAAI,CAACS,CAAC,EAAE;IACJ,OAAO,IAAI,CAACvB,KAAK,CAAC,IAAI,CAACA,KAAK,CAAC/B,MAAM,GAAGsD,CAAC,CAAC;EAC5C;EACA,CAACb,GAAG,CAACc,KAAK,EAAE;IACR,MAAMpD,KAAK,GAAGoD,KAAK,IAAI,IAAI,CAACxB,KAAK,CAACU,GAAG,EAAE;IACvC;IACA,IAAI,CAACtC,KAAK,EAAE;MACR,MAAMqC,OAAO,GAAG,6BAA6B;MAC7C,MAAM;QAAE1C,IAAI,EAAE,OAAO;QAAE+B,MAAM,EAAE,IAAI,CAACA,MAAM;QAAEG,MAAM,EAAE,EAAE;QAAEQ;MAAQ,CAAC;IACrE,CAAC,MACI,IAAI,IAAI,CAACT,KAAK,CAAC/B,MAAM,KAAK,CAAC,EAAE;MAC9B,MAAMG,KAAK;IACf,CAAC,MACI;MACD,MAAMyC,GAAG,GAAG,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;MACxB,IAAI1C,KAAK,CAACL,IAAI,KAAK,cAAc,EAAE;QAC/B;QACAK,KAAK,CAACyB,MAAM,GAAG,QAAQ,IAAIgB,GAAG,GAAGA,GAAG,CAAChB,MAAM,GAAG,CAAC;MACnD,CAAC,MACI,IAAIzB,KAAK,CAACL,IAAI,KAAK,iBAAiB,IAAI8C,GAAG,CAAC9C,IAAI,KAAK,UAAU,EAAE;QAClE;QACAK,KAAK,CAACyB,MAAM,GAAG,CAAC;MACpB;MACA,IAAIzB,KAAK,CAACL,IAAI,KAAK,iBAAiB,EAChCgB,eAAe,CAACX,KAAK,CAAC;MAC1B,QAAQyC,GAAG,CAAC9C,IAAI;QACZ,KAAK,UAAU;UACX8C,GAAG,CAAC5B,KAAK,GAAGb,KAAK;UACjB;QACJ,KAAK,cAAc;UACfyC,GAAG,CAACY,KAAK,CAACnC,IAAI,CAAClB,KAAK,CAAC,CAAC,CAAC;UACvB;QACJ,KAAK,WAAW;UAAE;YACd,MAAMI,EAAE,GAAGqC,GAAG,CAACpC,KAAK,CAACoC,GAAG,CAACpC,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;YAC1C,IAAIO,EAAE,CAACS,KAAK,EAAE;cACV4B,GAAG,CAACpC,KAAK,CAACa,IAAI,CAAC;gBAAEf,KAAK,EAAE,EAAE;gBAAEW,GAAG,EAAEd,KAAK;gBAAEM,GAAG,EAAE;cAAG,CAAC,CAAC;cAClD,IAAI,CAACqB,SAAS,GAAG,IAAI;cACrB;YACJ,CAAC,MACI,IAAIvB,EAAE,CAACE,GAAG,EAAE;cACbF,EAAE,CAACS,KAAK,GAAGb,KAAK;YACpB,CAAC,MACI;cACDsD,MAAM,CAACC,MAAM,CAACnD,EAAE,EAAE;gBAAEU,GAAG,EAAEd,KAAK;gBAAEM,GAAG,EAAE;cAAG,CAAC,CAAC;cAC1C,IAAI,CAACqB,SAAS,GAAG,CAAClC,aAAa,CAACW,EAAE,CAACD,KAAK,EAAE,kBAAkB,CAAC;cAC7D;YACJ;YACA;UACJ;QACA,KAAK,WAAW;UAAE;YACd,MAAMC,EAAE,GAAGqC,GAAG,CAACpC,KAAK,CAACoC,GAAG,CAACpC,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;YAC1C,IAAIO,EAAE,CAACS,KAAK,EACR4B,GAAG,CAACpC,KAAK,CAACa,IAAI,CAAC;cAAEf,KAAK,EAAE,EAAE;cAAEU,KAAK,EAAEb;YAAM,CAAC,CAAC,CAAC,KAE5CI,EAAE,CAACS,KAAK,GAAGb,KAAK;YACpB;UACJ;QACA,KAAK,iBAAiB;UAAE;YACpB,MAAMI,EAAE,GAAGqC,GAAG,CAACpC,KAAK,CAACoC,GAAG,CAACpC,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;YAC1C,IAAI,CAACO,EAAE,IAAIA,EAAE,CAACS,KAAK,EACf4B,GAAG,CAACpC,KAAK,CAACa,IAAI,CAAC;cAAEf,KAAK,EAAE,EAAE;cAAEW,GAAG,EAAEd,KAAK;cAAEM,GAAG,EAAE;YAAG,CAAC,CAAC,CAAC,KAClD,IAAIF,EAAE,CAACE,GAAG,EACXF,EAAE,CAACS,KAAK,GAAGb,KAAK,CAAC,KAEjBsD,MAAM,CAACC,MAAM,CAACnD,EAAE,EAAE;cAAEU,GAAG,EAAEd,KAAK;cAAEM,GAAG,EAAE;YAAG,CAAC,CAAC;YAC9C;UACJ;QACA;QACA;UACI,OAAO,IAAI,CAACgC,GAAG,EAAE;UACjB,OAAO,IAAI,CAACA,GAAG,CAACtC,KAAK,CAAC;MAAC;MAE/B,IAAI,CAACyC,GAAG,CAAC9C,IAAI,KAAK,UAAU,IACxB8C,GAAG,CAAC9C,IAAI,KAAK,WAAW,IACxB8C,GAAG,CAAC9C,IAAI,KAAK,WAAW,MACvBK,KAAK,CAACL,IAAI,KAAK,WAAW,IAAIK,KAAK,CAACL,IAAI,KAAK,WAAW,CAAC,EAAE;QAC5D,MAAM6D,IAAI,GAAGxD,KAAK,CAACK,KAAK,CAACL,KAAK,CAACK,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;QAChD,IAAI2D,IAAI,IACJ,CAACA,IAAI,CAAClD,GAAG,IACT,CAACkD,IAAI,CAAC3C,KAAK,IACX2C,IAAI,CAACrD,KAAK,CAACN,MAAM,GAAG,CAAC,IACrBC,iBAAiB,CAAC0D,IAAI,CAACrD,KAAK,CAAC,KAAK,CAAC,CAAC,KACnCH,KAAK,CAACyB,MAAM,KAAK,CAAC,IACf+B,IAAI,CAACrD,KAAK,CAACsD,KAAK,CAACjB,EAAE,IAAIA,EAAE,CAAC7C,IAAI,KAAK,SAAS,IAAI6C,EAAE,CAACf,MAAM,GAAGzB,KAAK,CAACyB,MAAM,CAAC,CAAC,EAAE;UAChF,IAAIgB,GAAG,CAAC9C,IAAI,KAAK,UAAU,EACvB8C,GAAG,CAAC1B,GAAG,GAAGyC,IAAI,CAACrD,KAAK,CAAC,KAErBsC,GAAG,CAACpC,KAAK,CAACa,IAAI,CAAC;YAAEf,KAAK,EAAEqD,IAAI,CAACrD;UAAM,CAAC,CAAC;UACzCH,KAAK,CAACK,KAAK,CAACK,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QAC7B;MACJ;IACJ;EACJ;EACA,CAACiC,MAAM,GAAG;IACN,QAAQ,IAAI,CAAChD,IAAI;MACb,KAAK,gBAAgB;QACjB,MAAM;UAAEA,IAAI,EAAE,WAAW;UAAE+B,MAAM,EAAE,IAAI,CAACA,MAAM;UAAEG,MAAM,EAAE,IAAI,CAACA;QAAO,CAAC;QACrE;MACJ,KAAK,iBAAiB;MACtB,KAAK,OAAO;MACZ,KAAK,SAAS;MACd,KAAK,SAAS;QACV,MAAM,IAAI,CAACU,WAAW;QACtB;MACJ,KAAK,UAAU;MACf,KAAK,WAAW;QAAE;UACd,MAAMmB,GAAG,GAAG;YACR/D,IAAI,EAAE,UAAU;YAChB+B,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBvB,KAAK,EAAE;UACX,CAAC;UACD,IAAI,IAAI,CAACR,IAAI,KAAK,WAAW,EACzB+D,GAAG,CAACvD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UACpC,IAAI,CAACX,KAAK,CAACV,IAAI,CAACwC,GAAG,CAAC;UACpB;QACJ;IAAC;IAEL,MAAM;MACF/D,IAAI,EAAE,OAAO;MACb+B,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBW,OAAO,EAAG,cAAa,IAAI,CAAC1C,IAAK,uBAAsB;MACvDkC,MAAM,EAAE,IAAI,CAACA;IACjB,CAAC;EACL;EACA,CAACe,QAAQ,CAACc,GAAG,EAAE;IACX,IAAIA,GAAG,CAAC7C,KAAK,EACT,OAAO,OAAO,IAAI,CAAC8C,OAAO,CAACD,GAAG,CAAC;IACnC,QAAQ,IAAI,CAAC/D,IAAI;MACb,KAAK,WAAW;QAAE;UACd,IAAIG,iBAAiB,CAAC4D,GAAG,CAACvD,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;YACrC,OAAO,IAAI,CAACmC,GAAG,EAAE;YACjB,OAAO,IAAI,CAACF,IAAI,EAAE;UACtB,CAAC,MAEGsB,GAAG,CAACvD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UACpC;QACJ;MACA,KAAK,QAAQ;MACb,KAAK,KAAK;MACV,KAAK,OAAO;MACZ,KAAK,SAAS;MACd,KAAK,SAAS;QACVmB,GAAG,CAACvD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QAChC;IAAO;IAEf,MAAMqB,EAAE,GAAG,IAAI,CAACC,eAAe,CAACH,GAAG,CAAC;IACpC,IAAIE,EAAE,EACF,IAAI,CAAChC,KAAK,CAACV,IAAI,CAAC0C,EAAE,CAAC,CAAC,KACnB;MACD,MAAM;QACFjE,IAAI,EAAE,OAAO;QACb+B,MAAM,EAAE,IAAI,CAACA,MAAM;QACnBW,OAAO,EAAG,cAAa,IAAI,CAAC1C,IAAK,yBAAwB;QACzDkC,MAAM,EAAE,IAAI,CAACA;MACjB,CAAC;IACL;EACJ;EACA,CAACgB,MAAM,CAACA,MAAM,EAAE;IACZ,IAAI,IAAI,CAAClD,IAAI,KAAK,eAAe,EAAE;MAC/B,MAAMa,IAAI,GAAGP,YAAY,CAAC,IAAI,CAACyC,IAAI,CAAC,CAAC,CAAC,CAAC;MACvC,MAAMvC,KAAK,GAAGI,qBAAqB,CAACC,IAAI,CAAC;MACzC,IAAIF,GAAG;MACP,IAAIuC,MAAM,CAAC9B,GAAG,EAAE;QACZT,GAAG,GAAGuC,MAAM,CAAC9B,GAAG;QAChBT,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QAC1B,OAAOM,MAAM,CAAC9B,GAAG;MACrB,CAAC,MAEGT,GAAG,GAAG,CAAC,IAAI,CAACiC,WAAW,CAAC;MAC5B,MAAMuB,GAAG,GAAG;QACRnE,IAAI,EAAE,WAAW;QACjB+B,MAAM,EAAEmB,MAAM,CAACnB,MAAM;QACrBD,MAAM,EAAEoB,MAAM,CAACpB,MAAM;QACrBpB,KAAK,EAAE,CAAC;UAAEF,KAAK;UAAEW,GAAG,EAAE+B,MAAM;UAAEvC;QAAI,CAAC;MACvC,CAAC;MACD,IAAI,CAACqB,SAAS,GAAG,IAAI;MACrB,IAAI,CAACC,KAAK,CAAC,IAAI,CAACA,KAAK,CAAC/B,MAAM,GAAG,CAAC,CAAC,GAAGiE,GAAG;IAC3C,CAAC,MAEG,OAAO,IAAI,CAACH,OAAO,CAACd,MAAM,CAAC;EACnC;EACA,CAACC,WAAW,CAACD,MAAM,EAAE;IACjB,QAAQ,IAAI,CAAClD,IAAI;MACb,KAAK,OAAO;MACZ,KAAK,SAAS;MACd,KAAK,SAAS;QACVkD,MAAM,CAACQ,KAAK,CAACnC,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACnC;MACJ,KAAK,QAAQ;QACTM,MAAM,CAAChB,MAAM,GAAG,IAAI,CAACA,MAAM;QAC3B;QACA,IAAI,CAACN,SAAS,GAAG,IAAI;QACrB,IAAI,CAACE,MAAM,GAAG,CAAC;QACf,IAAI,IAAI,CAACH,SAAS,EAAE;UAChB,IAAIyC,EAAE,GAAG,IAAI,CAAClC,MAAM,CAACmC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;UACtC,OAAOD,EAAE,KAAK,CAAC,EAAE;YACb,IAAI,CAACzC,SAAS,CAAC,IAAI,CAACI,MAAM,GAAGqC,EAAE,CAAC;YAChCA,EAAE,GAAG,IAAI,CAAClC,MAAM,CAACmC,OAAO,CAAC,IAAI,EAAED,EAAE,CAAC,GAAG,CAAC;UAC1C;QACJ;QACA,OAAO,IAAI,CAACzB,GAAG,EAAE;QACjB;MACJ;MACA;QACI,OAAO,IAAI,CAACA,GAAG,EAAE;QACjB,OAAO,IAAI,CAACF,IAAI,EAAE;IAAC;EAE/B;EACA,CAACW,QAAQ,CAACe,GAAG,EAAE;IACX,MAAM1D,EAAE,GAAG0D,GAAG,CAACzD,KAAK,CAACyD,GAAG,CAACzD,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;IAC1C;IACA,QAAQ,IAAI,CAACF,IAAI;MACb,KAAK,SAAS;QACV,IAAI,CAACgC,SAAS,GAAG,KAAK;QACtB,IAAIvB,EAAE,CAACS,KAAK,EAAE;UACV,MAAME,GAAG,GAAG,KAAK,IAAIX,EAAE,CAACS,KAAK,GAAGT,EAAE,CAACS,KAAK,CAACE,GAAG,GAAGkD,SAAS;UACxD,MAAMT,IAAI,GAAGxC,KAAK,CAACkD,OAAO,CAACnD,GAAG,CAAC,GAAGA,GAAG,CAACA,GAAG,CAAClB,MAAM,GAAG,CAAC,CAAC,GAAGoE,SAAS;UACjE,IAAIT,IAAI,EAAE7D,IAAI,KAAK,SAAS,EACxBoB,GAAG,EAAEG,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC,CAAC,KAE5BuB,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;YAAEf,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;UAAE,CAAC,CAAC;QACrD,CAAC,MACI,IAAInC,EAAE,CAACE,GAAG,EAAE;UACbF,EAAE,CAACE,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACjC,CAAC,MACI;UACDnC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACnC;QACA;MACJ,KAAK,OAAO;MACZ,KAAK,SAAS;QACV,IAAInC,EAAE,CAACS,KAAK,EAAE;UACViD,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;YAAEf,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;UAAE,CAAC,CAAC;QACjD,CAAC,MACI,IAAInC,EAAE,CAACE,GAAG,EAAE;UACbF,EAAE,CAACE,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACjC,CAAC,MACI;UACD,IAAI,IAAI,CAAC4B,iBAAiB,CAAC/D,EAAE,CAACD,KAAK,EAAE2D,GAAG,CAACrC,MAAM,CAAC,EAAE;YAC9C,MAAMjB,IAAI,GAAGsD,GAAG,CAACzD,KAAK,CAACyD,GAAG,CAACzD,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;YAC5C,MAAMkB,GAAG,GAAGP,IAAI,EAAEK,KAAK,EAAEE,GAAG;YAC5B,IAAIC,KAAK,CAACkD,OAAO,CAACnD,GAAG,CAAC,EAAE;cACpBC,KAAK,CAACC,SAAS,CAACC,IAAI,CAACC,KAAK,CAACJ,GAAG,EAAEX,EAAE,CAACD,KAAK,CAAC;cACzCY,GAAG,CAACG,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;cAC1BuB,GAAG,CAACzD,KAAK,CAACiC,GAAG,EAAE;cACf;YACJ;UACJ;UACAlC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACnC;QACA;IAAO;IAEf,IAAI,IAAI,CAACd,MAAM,IAAIqC,GAAG,CAACrC,MAAM,EAAE;MAC3B,MAAM2C,UAAU,GAAG,CAAC,IAAI,CAACzC,SAAS,IAAI,IAAI,CAACF,MAAM,KAAKqC,GAAG,CAACrC,MAAM,IAAIrB,EAAE,CAACE,GAAG;MAC1E;MACA,IAAIH,KAAK,GAAG,EAAE;MACd,IAAIiE,UAAU,IAAIhE,EAAE,CAACE,GAAG,IAAI,CAACF,EAAE,CAACS,KAAK,EAAE;QACnC,MAAMkD,EAAE,GAAG,EAAE;QACb,KAAK,IAAInE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,EAAE,CAACE,GAAG,CAACT,MAAM,EAAE,EAAED,CAAC,EAAE;UACpC,MAAM4C,EAAE,GAAGpC,EAAE,CAACE,GAAG,CAACV,CAAC,CAAC;UACpB,QAAQ4C,EAAE,CAAC7C,IAAI;YACX,KAAK,SAAS;cACVoE,EAAE,CAAC7C,IAAI,CAACtB,CAAC,CAAC;cACV;YACJ,KAAK,OAAO;cACR;YACJ,KAAK,SAAS;cACV,IAAI4C,EAAE,CAACf,MAAM,GAAGqC,GAAG,CAACrC,MAAM,EACtBsC,EAAE,CAAClE,MAAM,GAAG,CAAC;cACjB;YACJ;cACIkE,EAAE,CAAClE,MAAM,GAAG,CAAC;UAAC;QAE1B;QACA,IAAIkE,EAAE,CAAClE,MAAM,IAAI,CAAC,EACdM,KAAK,GAAGC,EAAE,CAACE,GAAG,CAACI,MAAM,CAACqD,EAAE,CAAC,CAAC,CAAC,CAAC;MACpC;MACA,QAAQ,IAAI,CAACpE,IAAI;QACb,KAAK,QAAQ;QACb,KAAK,KAAK;UACN,IAAIyE,UAAU,IAAIhE,EAAE,CAACS,KAAK,EAAE;YACxBV,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;YAC5BuB,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;cAAEf;YAAM,CAAC,CAAC;YACzB,IAAI,CAACwB,SAAS,GAAG,IAAI;UACzB,CAAC,MACI,IAAIvB,EAAE,CAACE,GAAG,EAAE;YACbF,EAAE,CAACE,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UACjC,CAAC,MACI;YACDnC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UACnC;UACA;QACJ,KAAK,kBAAkB;UACnB,IAAI,CAACnC,EAAE,CAACE,GAAG,IAAI,CAACb,aAAa,CAACW,EAAE,CAACD,KAAK,EAAE,kBAAkB,CAAC,EAAE;YACzDC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UACnC,CAAC,MACI,IAAI6B,UAAU,IAAIhE,EAAE,CAACS,KAAK,EAAE;YAC7BV,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;YAC5BuB,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;cAAEf;YAAM,CAAC,CAAC;UAC7B,CAAC,MACI;YACD,IAAI,CAACyB,KAAK,CAACV,IAAI,CAAC;cACZvB,IAAI,EAAE,WAAW;cACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;cACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;cACnBpB,KAAK,EAAE,CAAC;gBAAEF,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;cAAE,CAAC;YACzC,CAAC,CAAC;UACN;UACA,IAAI,CAACZ,SAAS,GAAG,IAAI;UACrB;QACJ,KAAK,eAAe;UAChB,IAAIlC,aAAa,CAACW,EAAE,CAACD,KAAK,EAAE,kBAAkB,CAAC,EAAE;YAC7C,IAAI,CAACC,EAAE,CAACE,GAAG,EAAE;cACT,IAAIb,aAAa,CAACW,EAAE,CAACD,KAAK,EAAE,SAAS,CAAC,EAAE;gBACpCmD,MAAM,CAACC,MAAM,CAACnD,EAAE,EAAE;kBAAEU,GAAG,EAAE,IAAI;kBAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;gBAAE,CAAC,CAAC;cAC7D,CAAC,MACI;gBACD,MAAMpC,KAAK,GAAGI,qBAAqB,CAACH,EAAE,CAACD,KAAK,CAAC;gBAC7C,IAAI,CAACyB,KAAK,CAACV,IAAI,CAAC;kBACZvB,IAAI,EAAE,WAAW;kBACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;kBACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;kBACnBpB,KAAK,EAAE,CAAC;oBAAEF,KAAK;oBAAEW,GAAG,EAAE,IAAI;oBAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;kBAAE,CAAC;gBACzD,CAAC,CAAC;cACN;YACJ,CAAC,MACI,IAAInC,EAAE,CAACS,KAAK,EAAE;cACfiD,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;gBAAEf,KAAK,EAAE,EAAE;gBAAEW,GAAG,EAAE,IAAI;gBAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;cAAE,CAAC,CAAC;YACrE,CAAC,MACI,IAAI9C,aAAa,CAACW,EAAE,CAACE,GAAG,EAAE,eAAe,CAAC,EAAE;cAC7C,IAAI,CAACsB,KAAK,CAACV,IAAI,CAAC;gBACZvB,IAAI,EAAE,WAAW;gBACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;gBACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;gBACnBpB,KAAK,EAAE,CAAC;kBAAEF,KAAK;kBAAEW,GAAG,EAAE,IAAI;kBAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;gBAAE,CAAC;cACzD,CAAC,CAAC;YACN,CAAC,MACI,IAAIxC,WAAW,CAACK,EAAE,CAACU,GAAG,CAAC,IACxB,CAACrB,aAAa,CAACW,EAAE,CAACE,GAAG,EAAE,SAAS,CAAC,EAAE;cACnC,MAAMH,KAAK,GAAGI,qBAAqB,CAACH,EAAE,CAACD,KAAK,CAAC;cAC7C,MAAMW,GAAG,GAAGV,EAAE,CAACU,GAAG;cAClB,MAAMR,GAAG,GAAGF,EAAE,CAACE,GAAG;cAClBA,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;cAC1B;cACA,OAAOnC,EAAE,CAACU,GAAG,EAAE,OAAOV,EAAE,CAACE,GAAG;cAC5B,IAAI,CAACsB,KAAK,CAACV,IAAI,CAAC;gBACZvB,IAAI,EAAE,WAAW;gBACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;gBACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;gBACnBpB,KAAK,EAAE,CAAC;kBAAEF,KAAK;kBAAEW,GAAG;kBAAER;gBAAI,CAAC;cAC/B,CAAC,CAAC;YACN,CAAC,MACI,IAAIH,KAAK,CAACN,MAAM,GAAG,CAAC,EAAE;cACvB;cACAO,EAAE,CAACE,GAAG,GAAGF,EAAE,CAACE,GAAG,CAAC+D,MAAM,CAAClE,KAAK,EAAE,IAAI,CAACoC,WAAW,CAAC;YACnD,CAAC,MACI;cACDnC,EAAE,CAACE,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;YACjC;UACJ,CAAC,MACI;YACD,IAAI,CAACnC,EAAE,CAACE,GAAG,EAAE;cACTgD,MAAM,CAACC,MAAM,CAACnD,EAAE,EAAE;gBAAEU,GAAG,EAAE,IAAI;gBAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;cAAE,CAAC,CAAC;YAC7D,CAAC,MACI,IAAInC,EAAE,CAACS,KAAK,IAAIuD,UAAU,EAAE;cAC7BN,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;gBAAEf,KAAK;gBAAEW,GAAG,EAAE,IAAI;gBAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;cAAE,CAAC,CAAC;YACjE,CAAC,MACI,IAAI9C,aAAa,CAACW,EAAE,CAACE,GAAG,EAAE,eAAe,CAAC,EAAE;cAC7C,IAAI,CAACsB,KAAK,CAACV,IAAI,CAAC;gBACZvB,IAAI,EAAE,WAAW;gBACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;gBACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;gBACnBpB,KAAK,EAAE,CAAC;kBAAEF,KAAK,EAAE,EAAE;kBAAEW,GAAG,EAAE,IAAI;kBAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;gBAAE,CAAC;cAC7D,CAAC,CAAC;YACN,CAAC,MACI;cACDnC,EAAE,CAACE,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;YACjC;UACJ;UACA,IAAI,CAACZ,SAAS,GAAG,IAAI;UACrB;QACJ,KAAK,OAAO;QACZ,KAAK,QAAQ;QACb,KAAK,sBAAsB;QAC3B,KAAK,sBAAsB;UAAE;YACzB,MAAM2C,EAAE,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAAC5E,IAAI,CAAC;YACrC,IAAIyE,UAAU,IAAIhE,EAAE,CAACS,KAAK,EAAE;cACxBiD,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;gBAAEf,KAAK;gBAAEW,GAAG,EAAEwD,EAAE;gBAAEhE,GAAG,EAAE;cAAG,CAAC,CAAC;cAC3C,IAAI,CAACqB,SAAS,GAAG,IAAI;YACzB,CAAC,MACI,IAAIvB,EAAE,CAACE,GAAG,EAAE;cACb,IAAI,CAACsB,KAAK,CAACV,IAAI,CAACoD,EAAE,CAAC;YACvB,CAAC,MACI;cACDhB,MAAM,CAACC,MAAM,CAACnD,EAAE,EAAE;gBAAEU,GAAG,EAAEwD,EAAE;gBAAEhE,GAAG,EAAE;cAAG,CAAC,CAAC;cACvC,IAAI,CAACqB,SAAS,GAAG,IAAI;YACzB;YACA;UACJ;QACA;UAAS;YACL,MAAMiC,EAAE,GAAG,IAAI,CAACC,eAAe,CAACC,GAAG,CAAC;YACpC,IAAIF,EAAE,EAAE;cACJ,IAAIQ,UAAU,IACVR,EAAE,CAACjE,IAAI,KAAK,WAAW,IACvBF,aAAa,CAACW,EAAE,CAACD,KAAK,EAAE,kBAAkB,CAAC,EAAE;gBAC7C2D,GAAG,CAACzD,KAAK,CAACa,IAAI,CAAC;kBAAEf;gBAAM,CAAC,CAAC;cAC7B;cACA,IAAI,CAACyB,KAAK,CAACV,IAAI,CAAC0C,EAAE,CAAC;cACnB;YACJ;UACJ;MAAC;IAET;IACA,OAAO,IAAI,CAACtB,GAAG,EAAE;IACjB,OAAO,IAAI,CAACF,IAAI,EAAE;EACtB;EACA,CAACY,aAAa,CAACwB,GAAG,EAAE;IAChB,MAAMpE,EAAE,GAAGoE,GAAG,CAACnE,KAAK,CAACmE,GAAG,CAACnE,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;IAC1C,QAAQ,IAAI,CAACF,IAAI;MACb,KAAK,SAAS;QACV,IAAIS,EAAE,CAACS,KAAK,EAAE;UACV,MAAME,GAAG,GAAG,KAAK,IAAIX,EAAE,CAACS,KAAK,GAAGT,EAAE,CAACS,KAAK,CAACE,GAAG,GAAGkD,SAAS;UACxD,MAAMT,IAAI,GAAGxC,KAAK,CAACkD,OAAO,CAACnD,GAAG,CAAC,GAAGA,GAAG,CAACA,GAAG,CAAClB,MAAM,GAAG,CAAC,CAAC,GAAGoE,SAAS;UACjE,IAAIT,IAAI,EAAE7D,IAAI,KAAK,SAAS,EACxBoB,GAAG,EAAEG,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC,CAAC,KAE5BiC,GAAG,CAACnE,KAAK,CAACa,IAAI,CAAC;YAAEf,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;UAAE,CAAC,CAAC;QACrD,CAAC,MAEGnC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACnC;MACJ,KAAK,OAAO;MACZ,KAAK,SAAS;QACV,IAAInC,EAAE,CAACS,KAAK,EACR2D,GAAG,CAACnE,KAAK,CAACa,IAAI,CAAC;UAAEf,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;QAAE,CAAC,CAAC,CAAC,KAC7C;UACD,IAAI,IAAI,CAAC4B,iBAAiB,CAAC/D,EAAE,CAACD,KAAK,EAAEqE,GAAG,CAAC/C,MAAM,CAAC,EAAE;YAC9C,MAAMjB,IAAI,GAAGgE,GAAG,CAACnE,KAAK,CAACmE,GAAG,CAACnE,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;YAC5C,MAAMkB,GAAG,GAAGP,IAAI,EAAEK,KAAK,EAAEE,GAAG;YAC5B,IAAIC,KAAK,CAACkD,OAAO,CAACnD,GAAG,CAAC,EAAE;cACpBC,KAAK,CAACC,SAAS,CAACC,IAAI,CAACC,KAAK,CAACJ,GAAG,EAAEX,EAAE,CAACD,KAAK,CAAC;cACzCY,GAAG,CAACG,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;cAC1BiC,GAAG,CAACnE,KAAK,CAACiC,GAAG,EAAE;cACf;YACJ;UACJ;UACAlC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACnC;QACA;MACJ,KAAK,QAAQ;MACb,KAAK,KAAK;QACN,IAAInC,EAAE,CAACS,KAAK,IAAI,IAAI,CAACY,MAAM,IAAI+C,GAAG,CAAC/C,MAAM,EACrC;QACJrB,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QAC/B;MACJ,KAAK,cAAc;QACf,IAAI,IAAI,CAACd,MAAM,KAAK+C,GAAG,CAAC/C,MAAM,EAC1B;QACJ,IAAIrB,EAAE,CAACS,KAAK,IAAIpB,aAAa,CAACW,EAAE,CAACD,KAAK,EAAE,cAAc,CAAC,EACnDqE,GAAG,CAACnE,KAAK,CAACa,IAAI,CAAC;UAAEf,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;QAAE,CAAC,CAAC,CAAC,KAE9CnC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QACnC;IAAO;IAEf,IAAI,IAAI,CAACd,MAAM,GAAG+C,GAAG,CAAC/C,MAAM,EAAE;MAC1B,MAAMmC,EAAE,GAAG,IAAI,CAACC,eAAe,CAACW,GAAG,CAAC;MACpC,IAAIZ,EAAE,EAAE;QACJ,IAAI,CAAChC,KAAK,CAACV,IAAI,CAAC0C,EAAE,CAAC;QACnB;MACJ;IACJ;IACA,OAAO,IAAI,CAACtB,GAAG,EAAE;IACjB,OAAO,IAAI,CAACF,IAAI,EAAE;EACtB;EACA,CAACa,cAAc,CAACrC,EAAE,EAAE;IAChB,MAAMR,EAAE,GAAGQ,EAAE,CAACP,KAAK,CAACO,EAAE,CAACP,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC;IACxC,IAAI,IAAI,CAACF,IAAI,KAAK,gBAAgB,EAAE;MAChC,IAAI8C,GAAG;MACP,GAAG;QACC,OAAO,IAAI,CAACH,GAAG,EAAE;QACjBG,GAAG,GAAG,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC;MACtB,CAAC,QAAQD,GAAG,IAAIA,GAAG,CAAC9C,IAAI,KAAK,iBAAiB;IAClD,CAAC,MACI,IAAIiB,EAAE,CAACG,GAAG,CAAClB,MAAM,KAAK,CAAC,EAAE;MAC1B,QAAQ,IAAI,CAACF,IAAI;QACb,KAAK,OAAO;QACZ,KAAK,kBAAkB;UACnB,IAAI,CAACS,EAAE,IAAIA,EAAE,CAACE,GAAG,EACbM,EAAE,CAACP,KAAK,CAACa,IAAI,CAAC;YAAEf,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;UAAE,CAAC,CAAC,CAAC,KAE7CnC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UACnC;QACJ,KAAK,eAAe;UAChB,IAAI,CAACnC,EAAE,IAAIA,EAAE,CAACS,KAAK,EACfD,EAAE,CAACP,KAAK,CAACa,IAAI,CAAC;YAAEf,KAAK,EAAE,EAAE;YAAEW,GAAG,EAAE,IAAI;YAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;UAAE,CAAC,CAAC,CAAC,KAChE,IAAInC,EAAE,CAACE,GAAG,EACXF,EAAE,CAACE,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC,CAAC,KAE9Be,MAAM,CAACC,MAAM,CAACnD,EAAE,EAAE;YAAEU,GAAG,EAAE,IAAI;YAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;UAAE,CAAC,CAAC;UAC7D;QACJ,KAAK,OAAO;QACZ,KAAK,SAAS;QACd,KAAK,SAAS;QACd,KAAK,QAAQ;QACb,KAAK,KAAK;UACN,IAAI,CAACnC,EAAE,IAAIA,EAAE,CAACS,KAAK,EACfD,EAAE,CAACP,KAAK,CAACa,IAAI,CAAC;YAAEf,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;UAAE,CAAC,CAAC,CAAC,KAC5C,IAAInC,EAAE,CAACE,GAAG,EACXF,EAAE,CAACE,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC,CAAC,KAE9BnC,EAAE,CAACD,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UACnC;QACJ,KAAK,OAAO;QACZ,KAAK,QAAQ;QACb,KAAK,sBAAsB;QAC3B,KAAK,sBAAsB;UAAE;YACzB,MAAM+B,EAAE,GAAG,IAAI,CAACC,UAAU,CAAC,IAAI,CAAC5E,IAAI,CAAC;YACrC,IAAI,CAACS,EAAE,IAAIA,EAAE,CAACS,KAAK,EACfD,EAAE,CAACP,KAAK,CAACa,IAAI,CAAC;cAAEf,KAAK,EAAE,EAAE;cAAEW,GAAG,EAAEwD,EAAE;cAAEhE,GAAG,EAAE;YAAG,CAAC,CAAC,CAAC,KAC9C,IAAIF,EAAE,CAACE,GAAG,EACX,IAAI,CAACsB,KAAK,CAACV,IAAI,CAACoD,EAAE,CAAC,CAAC,KAEpBhB,MAAM,CAACC,MAAM,CAACnD,EAAE,EAAE;cAAEU,GAAG,EAAEwD,EAAE;cAAEhE,GAAG,EAAE;YAAG,CAAC,CAAC;YAC3C;UACJ;QACA,KAAK,cAAc;QACnB,KAAK,cAAc;UACfM,EAAE,CAACG,GAAG,CAACG,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UAC7B;MAAO;MAEf,MAAMqB,EAAE,GAAG,IAAI,CAACC,eAAe,CAACjD,EAAE,CAAC;MACnC;MACA,IAAIgD,EAAE,EACF,IAAI,CAAChC,KAAK,CAACV,IAAI,CAAC0C,EAAE,CAAC,CAAC,KACnB;QACD,OAAO,IAAI,CAACtB,GAAG,EAAE;QACjB,OAAO,IAAI,CAACF,IAAI,EAAE;MACtB;IACJ,CAAC,MACI;MACD,MAAMlC,MAAM,GAAG,IAAI,CAACwC,IAAI,CAAC,CAAC,CAAC;MAC3B,IAAIxC,MAAM,CAACP,IAAI,KAAK,WAAW,KACzB,IAAI,CAACA,IAAI,KAAK,eAAe,IAAIO,MAAM,CAACuB,MAAM,KAAKb,EAAE,CAACa,MAAM,IACzD,IAAI,CAAC9B,IAAI,KAAK,SAAS,IACpB,CAACO,MAAM,CAACG,KAAK,CAACH,MAAM,CAACG,KAAK,CAACR,MAAM,GAAG,CAAC,CAAC,CAACS,GAAI,CAAC,EAAE;QACtD,OAAO,IAAI,CAACgC,GAAG,EAAE;QACjB,OAAO,IAAI,CAACF,IAAI,EAAE;MACtB,CAAC,MACI,IAAI,IAAI,CAACzC,IAAI,KAAK,eAAe,IAClCO,MAAM,CAACP,IAAI,KAAK,iBAAiB,EAAE;QACnC,MAAMa,IAAI,GAAGP,YAAY,CAACC,MAAM,CAAC;QACjC,MAAMC,KAAK,GAAGI,qBAAqB,CAACC,IAAI,CAAC;QACzCG,eAAe,CAACC,EAAE,CAAC;QACnB,MAAMN,GAAG,GAAGM,EAAE,CAACG,GAAG,CAACL,MAAM,CAAC,CAAC,EAAEE,EAAE,CAACG,GAAG,CAAClB,MAAM,CAAC;QAC3CS,GAAG,CAACY,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;QAC1B,MAAMuB,GAAG,GAAG;UACRnE,IAAI,EAAE,WAAW;UACjB+B,MAAM,EAAEd,EAAE,CAACc,MAAM;UACjBD,MAAM,EAAEb,EAAE,CAACa,MAAM;UACjBpB,KAAK,EAAE,CAAC;YAAEF,KAAK;YAAEW,GAAG,EAAEF,EAAE;YAAEN;UAAI,CAAC;QACnC,CAAC;QACD,IAAI,CAACqB,SAAS,GAAG,IAAI;QACrB,IAAI,CAACC,KAAK,CAAC,IAAI,CAACA,KAAK,CAAC/B,MAAM,GAAG,CAAC,CAAC,GAAGiE,GAAG;MAC3C,CAAC,MACI;QACD,OAAO,IAAI,CAACH,OAAO,CAAC/C,EAAE,CAAC;MAC3B;IACJ;EACJ;EACA2D,UAAU,CAAC5E,IAAI,EAAE;IACb,IAAI,IAAI,CAAC2B,SAAS,EAAE;MAChB,IAAIyC,EAAE,GAAG,IAAI,CAAClC,MAAM,CAACmC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC;MACtC,OAAOD,EAAE,KAAK,CAAC,EAAE;QACb,IAAI,CAACzC,SAAS,CAAC,IAAI,CAACI,MAAM,GAAGqC,EAAE,CAAC;QAChCA,EAAE,GAAG,IAAI,CAAClC,MAAM,CAACmC,OAAO,CAAC,IAAI,EAAED,EAAE,CAAC,GAAG,CAAC;MAC1C;IACJ;IACA,OAAO;MACHpE,IAAI;MACJ+B,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBI,MAAM,EAAE,IAAI,CAACA;IACjB,CAAC;EACL;EACAgC,eAAe,CAAC3D,MAAM,EAAE;IACpB,QAAQ,IAAI,CAACP,IAAI;MACb,KAAK,OAAO;MACZ,KAAK,QAAQ;MACb,KAAK,sBAAsB;MAC3B,KAAK,sBAAsB;QACvB,OAAO,IAAI,CAAC4E,UAAU,CAAC,IAAI,CAAC5E,IAAI,CAAC;MACrC,KAAK,qBAAqB;QACtB,OAAO;UACHA,IAAI,EAAE,cAAc;UACpB+B,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;UACnB4B,KAAK,EAAE,CAAC,IAAI,CAACd,WAAW,CAAC;UACzBV,MAAM,EAAE;QACZ,CAAC;MACL,KAAK,gBAAgB;MACrB,KAAK,gBAAgB;QACjB,OAAO;UACHlC,IAAI,EAAE,iBAAiB;UACvB+B,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBtB,KAAK,EAAE,IAAI,CAACoC,WAAW;UACvBlC,KAAK,EAAE,EAAE;UACTU,GAAG,EAAE;QACT,CAAC;MACL,KAAK,cAAc;QACf,OAAO;UACHpB,IAAI,EAAE,WAAW;UACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;UACnBpB,KAAK,EAAE,CAAC;YAAEF,KAAK,EAAE,CAAC,IAAI,CAACoC,WAAW;UAAE,CAAC;QACzC,CAAC;MACL,KAAK,kBAAkB;QAAE;UACrB,IAAI,CAACZ,SAAS,GAAG,IAAI;UACrB,MAAMnB,IAAI,GAAGP,YAAY,CAACC,MAAM,CAAC;UACjC,MAAMC,KAAK,GAAGI,qBAAqB,CAACC,IAAI,CAAC;UACzCL,KAAK,CAACe,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC;UAC5B,OAAO;YACH5C,IAAI,EAAE,WAAW;YACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBpB,KAAK,EAAE,CAAC;cAAEF;YAAM,CAAC;UACrB,CAAC;QACL;MACA,KAAK,eAAe;QAAE;UAClB,IAAI,CAACwB,SAAS,GAAG,IAAI;UACrB,MAAMnB,IAAI,GAAGP,YAAY,CAACC,MAAM,CAAC;UACjC,MAAMC,KAAK,GAAGI,qBAAqB,CAACC,IAAI,CAAC;UACzC,OAAO;YACHb,IAAI,EAAE,WAAW;YACjB+B,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBD,MAAM,EAAE,IAAI,CAACA,MAAM;YACnBpB,KAAK,EAAE,CAAC;cAAEF,KAAK;cAAEW,GAAG,EAAE,IAAI;cAAER,GAAG,EAAE,CAAC,IAAI,CAACiC,WAAW;YAAE,CAAC;UACzD,CAAC;QACL;IAAC;IAEL,OAAO,IAAI;EACf;EACA4B,iBAAiB,CAAChE,KAAK,EAAEsB,MAAM,EAAE;IAC7B,IAAI,IAAI,CAAC9B,IAAI,KAAK,SAAS,EACvB,OAAO,KAAK;IAChB,IAAI,IAAI,CAAC8B,MAAM,IAAIA,MAAM,EACrB,OAAO,KAAK;IAChB,OAAOtB,KAAK,CAACsD,KAAK,CAACjB,EAAE,IAAIA,EAAE,CAAC7C,IAAI,KAAK,SAAS,IAAI6C,EAAE,CAAC7C,IAAI,KAAK,OAAO,CAAC;EAC1E;EACA,CAACuD,WAAW,CAACuB,MAAM,EAAE;IACjB,IAAI,IAAI,CAAC9E,IAAI,KAAK,UAAU,EAAE;MAC1B,IAAI8E,MAAM,CAAC1D,GAAG,EACV0D,MAAM,CAAC1D,GAAG,CAACG,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC,CAAC,KAElCkC,MAAM,CAAC1D,GAAG,GAAG,CAAC,IAAI,CAACwB,WAAW,CAAC;MACnC,IAAI,IAAI,CAAC5C,IAAI,KAAK,SAAS,EACvB,OAAO,IAAI,CAAC2C,GAAG,EAAE;IACzB;EACJ;EACA,CAACqB,OAAO,CAAC3D,KAAK,EAAE;IACZ,QAAQ,IAAI,CAACL,IAAI;MACb,KAAK,OAAO;MACZ,KAAK,WAAW;MAChB,KAAK,SAAS;MACd,KAAK,cAAc;MACnB,KAAK,cAAc;MACnB,KAAK,eAAe;QAChB,OAAO,IAAI,CAAC2C,GAAG,EAAE;QACjB,OAAO,IAAI,CAACF,IAAI,EAAE;QAClB;MACJ,KAAK,SAAS;QACV,IAAI,CAACT,SAAS,GAAG,KAAK;MAC1B;MACA,KAAK,OAAO;MACZ,KAAK,SAAS;MACd;QACI;QACA,IAAI3B,KAAK,CAACe,GAAG,EACTf,KAAK,CAACe,GAAG,CAACG,IAAI,CAAC,IAAI,CAACqB,WAAW,CAAC,CAAC,KAEjCvC,KAAK,CAACe,GAAG,GAAG,CAAC,IAAI,CAACwB,WAAW,CAAC;QAClC,IAAI,IAAI,CAAC5C,IAAI,KAAK,SAAS,EACvB,OAAO,IAAI,CAAC2C,GAAG,EAAE;IAAC;EAElC;AACJ;AAEA,SAASlB,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}