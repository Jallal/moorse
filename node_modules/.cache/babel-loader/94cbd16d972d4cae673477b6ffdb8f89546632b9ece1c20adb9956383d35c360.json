{"ast":null,"code":"import { YAMLSeq } from '../../nodes/YAMLSeq.js';\nimport { toJS } from '../../nodes/toJS.js';\nimport { isScalar, isPair } from '../../nodes/Node.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\nimport { resolvePairs, createPairs } from './pairs.js';\nclass YAMLOMap extends YAMLSeq {\n  constructor() {\n    super();\n    this.add = YAMLMap.prototype.add.bind(this);\n    this.delete = YAMLMap.prototype.delete.bind(this);\n    this.get = YAMLMap.prototype.get.bind(this);\n    this.has = YAMLMap.prototype.has.bind(this);\n    this.set = YAMLMap.prototype.set.bind(this);\n    this.tag = YAMLOMap.tag;\n  }\n  /**\n   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n   * but TypeScript won't allow widening the signature of a child method.\n   */\n  toJSON(_, ctx) {\n    if (!ctx) return super.toJSON(_);\n    const map = new Map();\n    if (ctx?.onCreate) ctx.onCreate(map);\n    for (const pair of this.items) {\n      let key, value;\n      if (isPair(pair)) {\n        key = toJS(pair.key, '', ctx);\n        value = toJS(pair.value, key, ctx);\n      } else {\n        key = toJS(pair, '', ctx);\n      }\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n    return map;\n  }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n  collection: 'seq',\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve(seq, onError) {\n    const pairs = resolvePairs(seq, onError);\n    const seenKeys = [];\n    for (const {\n      key\n    } of pairs.items) {\n      if (isScalar(key)) {\n        if (seenKeys.includes(key.value)) {\n          onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n        } else {\n          seenKeys.push(key.value);\n        }\n      }\n    }\n    return Object.assign(new YAMLOMap(), pairs);\n  },\n  createNode(schema, iterable, ctx) {\n    const pairs = createPairs(schema, iterable, ctx);\n    const omap = new YAMLOMap();\n    omap.items = pairs.items;\n    return omap;\n  }\n};\nexport { YAMLOMap, omap };","map":{"version":3,"names":["YAMLSeq","toJS","isScalar","isPair","YAMLMap","resolvePairs","createPairs","YAMLOMap","constructor","add","prototype","bind","delete","get","has","set","tag","toJSON","_","ctx","map","Map","onCreate","pair","items","key","value","Error","omap","collection","identify","nodeClass","default","resolve","seq","onError","pairs","seenKeys","includes","push","Object","assign","createNode","schema","iterable"],"sources":["/Users/jhazzatgmail.com/Documents/moorseapp/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"],"sourcesContent":["import { YAMLSeq } from '../../nodes/YAMLSeq.js';\nimport { toJS } from '../../nodes/toJS.js';\nimport { isScalar, isPair } from '../../nodes/Node.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\nimport { resolvePairs, createPairs } from './pairs.js';\n\nclass YAMLOMap extends YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (isPair(pair)) {\n                key = toJS(pair.key, '', ctx);\n                value = toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs = resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs.items) {\n            if (isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs);\n    },\n    createNode(schema, iterable, ctx) {\n        const pairs = createPairs(schema, iterable, ctx);\n        const omap = new YAMLOMap();\n        omap.items = pairs.items;\n        return omap;\n    }\n};\n\nexport { YAMLOMap, omap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}