{"ast":null,"code":"import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n  switch (ch) {\n    case undefined:\n    case ' ':\n    case '\\n':\n    case '\\r':\n    case '\\t':\n      return true;\n    default:\n      return false;\n  }\n}\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nconst invalidFlowScalarChars = ',[]{}'.split('');\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nconst isNotAnchorChar = ch => !ch || invalidAnchorChars.includes(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n  constructor() {\n    /**\n     * Flag indicating whether the end of the current buffer marks the end of\n     * all input\n     */\n    this.atEnd = false;\n    /**\n     * Explicit indent set in block scalar header, as an offset from the current\n     * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n     * explicitly set.\n     */\n    this.blockScalarIndent = -1;\n    /**\n     * Block scalars that include a + (keep) chomping indicator in their header\n     * include trailing empty lines, which are otherwise excluded from the\n     * scalar's contents.\n     */\n    this.blockScalarKeep = false;\n    /** Current input */\n    this.buffer = '';\n    /**\n     * Flag noting whether the map value indicator : can immediately follow this\n     * node within a flow context.\n     */\n    this.flowKey = false;\n    /** Count of surrounding flow collection levels. */\n    this.flowLevel = 0;\n    /**\n     * Minimum level of indentation required for next lines to be parsed as a\n     * part of the current scalar value.\n     */\n    this.indentNext = 0;\n    /** Indentation level of the current line. */\n    this.indentValue = 0;\n    /** Position of the next \\n character. */\n    this.lineEndPos = null;\n    /** Stores the state of the lexer if reaching the end of incpomplete input */\n    this.next = null;\n    /** A pointer to `buffer`; the current position of the lexer. */\n    this.pos = 0;\n  }\n  /**\n   * Generate YAML tokens from the `source` string. If `incomplete`,\n   * a part of the last line may be left as a buffer for the next call.\n   *\n   * @returns A generator of lexical tokens\n   */\n  lex(source) {\n    var _this = this;\n    let incomplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return function* () {\n      if (source) {\n        _this.buffer = _this.buffer ? _this.buffer + source : source;\n        _this.lineEndPos = null;\n      }\n      _this.atEnd = !incomplete;\n      let next = _this.next ?? 'stream';\n      while (next && (incomplete || _this.hasChars(1))) next = yield* _this.parseNext(next);\n    }();\n  }\n  atLineEnd() {\n    let i = this.pos;\n    let ch = this.buffer[i];\n    while (ch === ' ' || ch === '\\t') ch = this.buffer[++i];\n    if (!ch || ch === '#' || ch === '\\n') return true;\n    if (ch === '\\r') return this.buffer[i + 1] === '\\n';\n    return false;\n  }\n  charAt(n) {\n    return this.buffer[this.pos + n];\n  }\n  continueScalar(offset) {\n    let ch = this.buffer[offset];\n    if (this.indentNext > 0) {\n      let indent = 0;\n      while (ch === ' ') ch = this.buffer[++indent + offset];\n      if (ch === '\\r') {\n        const next = this.buffer[indent + offset + 1];\n        if (next === '\\n' || !next && !this.atEnd) return offset + indent + 1;\n      }\n      return ch === '\\n' || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;\n    }\n    if (ch === '-' || ch === '.') {\n      const dt = this.buffer.substr(offset, 3);\n      if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3])) return -1;\n    }\n    return offset;\n  }\n  getLine() {\n    let end = this.lineEndPos;\n    if (typeof end !== 'number' || end !== -1 && end < this.pos) {\n      end = this.buffer.indexOf('\\n', this.pos);\n      this.lineEndPos = end;\n    }\n    if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;\n    if (this.buffer[end - 1] === '\\r') end -= 1;\n    return this.buffer.substring(this.pos, end);\n  }\n  hasChars(n) {\n    return this.pos + n <= this.buffer.length;\n  }\n  setNext(state) {\n    this.buffer = this.buffer.substring(this.pos);\n    this.pos = 0;\n    this.lineEndPos = null;\n    this.next = state;\n    return null;\n  }\n  peek(n) {\n    return this.buffer.substr(this.pos, n);\n  }\n  *parseNext(next) {\n    switch (next) {\n      case 'stream':\n        return yield* this.parseStream();\n      case 'line-start':\n        return yield* this.parseLineStart();\n      case 'block-start':\n        return yield* this.parseBlockStart();\n      case 'doc':\n        return yield* this.parseDocument();\n      case 'flow':\n        return yield* this.parseFlowCollection();\n      case 'quoted-scalar':\n        return yield* this.parseQuotedScalar();\n      case 'block-scalar':\n        return yield* this.parseBlockScalar();\n      case 'plain-scalar':\n        return yield* this.parsePlainScalar();\n    }\n  }\n  *parseStream() {\n    let line = this.getLine();\n    if (line === null) return this.setNext('stream');\n    if (line[0] === BOM) {\n      yield* this.pushCount(1);\n      line = line.substring(1);\n    }\n    if (line[0] === '%') {\n      let dirEnd = line.length;\n      const cs = line.indexOf('#');\n      if (cs !== -1) {\n        const ch = line[cs - 1];\n        if (ch === ' ' || ch === '\\t') dirEnd = cs - 1;\n      }\n      while (true) {\n        const ch = line[dirEnd - 1];\n        if (ch === ' ' || ch === '\\t') dirEnd -= 1;else break;\n      }\n      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n      yield* this.pushCount(line.length - n); // possible comment\n      this.pushNewline();\n      return 'stream';\n    }\n    if (this.atLineEnd()) {\n      const sp = yield* this.pushSpaces(true);\n      yield* this.pushCount(line.length - sp);\n      yield* this.pushNewline();\n      return 'stream';\n    }\n    yield DOCUMENT;\n    return yield* this.parseLineStart();\n  }\n  *parseLineStart() {\n    const ch = this.charAt(0);\n    if (!ch && !this.atEnd) return this.setNext('line-start');\n    if (ch === '-' || ch === '.') {\n      if (!this.atEnd && !this.hasChars(4)) return this.setNext('line-start');\n      const s = this.peek(3);\n      if (s === '---' && isEmpty(this.charAt(3))) {\n        yield* this.pushCount(3);\n        this.indentValue = 0;\n        this.indentNext = 0;\n        return 'doc';\n      } else if (s === '...' && isEmpty(this.charAt(3))) {\n        yield* this.pushCount(3);\n        return 'stream';\n      }\n    }\n    this.indentValue = yield* this.pushSpaces(false);\n    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;\n    return yield* this.parseBlockStart();\n  }\n  *parseBlockStart() {\n    const [ch0, ch1] = this.peek(2);\n    if (!ch1 && !this.atEnd) return this.setNext('block-start');\n    if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n      this.indentNext = this.indentValue + 1;\n      this.indentValue += n;\n      return yield* this.parseBlockStart();\n    }\n    return 'doc';\n  }\n  *parseDocument() {\n    yield* this.pushSpaces(true);\n    const line = this.getLine();\n    if (line === null) return this.setNext('doc');\n    let n = yield* this.pushIndicators();\n    switch (line[n]) {\n      case '#':\n        yield* this.pushCount(line.length - n);\n      // fallthrough\n      case undefined:\n        yield* this.pushNewline();\n        return yield* this.parseLineStart();\n      case '{':\n      case '[':\n        yield* this.pushCount(1);\n        this.flowKey = false;\n        this.flowLevel = 1;\n        return 'flow';\n      case '}':\n      case ']':\n        // this is an error\n        yield* this.pushCount(1);\n        return 'doc';\n      case '*':\n        yield* this.pushUntil(isNotAnchorChar);\n        return 'doc';\n      case '\"':\n      case \"'\":\n        return yield* this.parseQuotedScalar();\n      case '|':\n      case '>':\n        n += yield* this.parseBlockScalarHeader();\n        n += yield* this.pushSpaces(true);\n        yield* this.pushCount(line.length - n);\n        yield* this.pushNewline();\n        return yield* this.parseBlockScalar();\n      default:\n        return yield* this.parsePlainScalar();\n    }\n  }\n  *parseFlowCollection() {\n    let nl, sp;\n    let indent = -1;\n    do {\n      nl = yield* this.pushNewline();\n      if (nl > 0) {\n        sp = yield* this.pushSpaces(false);\n        this.indentValue = indent = sp;\n      } else {\n        sp = 0;\n      }\n      sp += yield* this.pushSpaces(true);\n    } while (nl + sp > 0);\n    const line = this.getLine();\n    if (line === null) return this.setNext('flow');\n    if (indent !== -1 && indent < this.indentNext && line[0] !== '#' || indent === 0 && (line.startsWith('---') || line.startsWith('...')) && isEmpty(line[3])) {\n      // Allowing for the terminal ] or } at the same (rather than greater)\n      // indent level as the initial [ or { is technically invalid, but\n      // failing here would be surprising to users.\n      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === ']' || line[0] === '}');\n      if (!atFlowEndMarker) {\n        // this is an error\n        this.flowLevel = 0;\n        yield FLOW_END;\n        return yield* this.parseLineStart();\n      }\n    }\n    let n = 0;\n    while (line[n] === ',') {\n      n += yield* this.pushCount(1);\n      n += yield* this.pushSpaces(true);\n      this.flowKey = false;\n    }\n    n += yield* this.pushIndicators();\n    switch (line[n]) {\n      case undefined:\n        return 'flow';\n      case '#':\n        yield* this.pushCount(line.length - n);\n        return 'flow';\n      case '{':\n      case '[':\n        yield* this.pushCount(1);\n        this.flowKey = false;\n        this.flowLevel += 1;\n        return 'flow';\n      case '}':\n      case ']':\n        yield* this.pushCount(1);\n        this.flowKey = true;\n        this.flowLevel -= 1;\n        return this.flowLevel ? 'flow' : 'doc';\n      case '*':\n        yield* this.pushUntil(isNotAnchorChar);\n        return 'flow';\n      case '\"':\n      case \"'\":\n        this.flowKey = true;\n        return yield* this.parseQuotedScalar();\n      case ':':\n        {\n          const next = this.charAt(1);\n          if (this.flowKey || isEmpty(next) || next === ',') {\n            this.flowKey = false;\n            yield* this.pushCount(1);\n            yield* this.pushSpaces(true);\n            return 'flow';\n          }\n        }\n      // fallthrough\n      default:\n        this.flowKey = false;\n        return yield* this.parsePlainScalar();\n    }\n  }\n  *parseQuotedScalar() {\n    const quote = this.charAt(0);\n    let end = this.buffer.indexOf(quote, this.pos + 1);\n    if (quote === \"'\") {\n      while (end !== -1 && this.buffer[end + 1] === \"'\") end = this.buffer.indexOf(\"'\", end + 2);\n    } else {\n      // double-quote\n      while (end !== -1) {\n        let n = 0;\n        while (this.buffer[end - 1 - n] === '\\\\') n += 1;\n        if (n % 2 === 0) break;\n        end = this.buffer.indexOf('\"', end + 1);\n      }\n    }\n    // Only looking for newlines within the quotes\n    const qb = this.buffer.substring(0, end);\n    let nl = qb.indexOf('\\n', this.pos);\n    if (nl !== -1) {\n      while (nl !== -1) {\n        const cs = this.continueScalar(nl + 1);\n        if (cs === -1) break;\n        nl = qb.indexOf('\\n', cs);\n      }\n      if (nl !== -1) {\n        // this is an error caused by an unexpected unindent\n        end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n      }\n    }\n    if (end === -1) {\n      if (!this.atEnd) return this.setNext('quoted-scalar');\n      end = this.buffer.length;\n    }\n    yield* this.pushToIndex(end + 1, false);\n    return this.flowLevel ? 'flow' : 'doc';\n  }\n  *parseBlockScalarHeader() {\n    this.blockScalarIndent = -1;\n    this.blockScalarKeep = false;\n    let i = this.pos;\n    while (true) {\n      const ch = this.buffer[++i];\n      if (ch === '+') this.blockScalarKeep = true;else if (ch > '0' && ch <= '9') this.blockScalarIndent = Number(ch) - 1;else if (ch !== '-') break;\n    }\n    return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n  }\n  *parseBlockScalar() {\n    let nl = this.pos - 1; // may be -1 if this.pos === 0\n    let indent = 0;\n    let ch;\n    loop: for (let i = this.pos; ch = this.buffer[i]; ++i) {\n      switch (ch) {\n        case ' ':\n          indent += 1;\n          break;\n        case '\\n':\n          nl = i;\n          indent = 0;\n          break;\n        case '\\r':\n          {\n            const next = this.buffer[i + 1];\n            if (!next && !this.atEnd) return this.setNext('block-scalar');\n            if (next === '\\n') break;\n          }\n        // fallthrough\n        default:\n          break loop;\n      }\n    }\n    if (!ch && !this.atEnd) return this.setNext('block-scalar');\n    if (indent >= this.indentNext) {\n      if (this.blockScalarIndent === -1) this.indentNext = indent;else this.indentNext += this.blockScalarIndent;\n      do {\n        const cs = this.continueScalar(nl + 1);\n        if (cs === -1) break;\n        nl = this.buffer.indexOf('\\n', cs);\n      } while (nl !== -1);\n      if (nl === -1) {\n        if (!this.atEnd) return this.setNext('block-scalar');\n        nl = this.buffer.length;\n      }\n    }\n    if (!this.blockScalarKeep) {\n      do {\n        let i = nl - 1;\n        let ch = this.buffer[i];\n        if (ch === '\\r') ch = this.buffer[--i];\n        const lastChar = i; // Drop the line if last char not more indented\n        while (ch === ' ' || ch === '\\t') ch = this.buffer[--i];\n        if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar) nl = i;else break;\n      } while (true);\n    }\n    yield SCALAR;\n    yield* this.pushToIndex(nl + 1, true);\n    return yield* this.parseLineStart();\n  }\n  *parsePlainScalar() {\n    const inFlow = this.flowLevel > 0;\n    let end = this.pos - 1;\n    let i = this.pos - 1;\n    let ch;\n    while (ch = this.buffer[++i]) {\n      if (ch === ':') {\n        const next = this.buffer[i + 1];\n        if (isEmpty(next) || inFlow && next === ',') break;\n        end = i;\n      } else if (isEmpty(ch)) {\n        let next = this.buffer[i + 1];\n        if (ch === '\\r') {\n          if (next === '\\n') {\n            i += 1;\n            ch = '\\n';\n            next = this.buffer[i + 1];\n          } else end = i;\n        }\n        if (next === '#' || inFlow && invalidFlowScalarChars.includes(next)) break;\n        if (ch === '\\n') {\n          const cs = this.continueScalar(i + 1);\n          if (cs === -1) break;\n          i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n        }\n      } else {\n        if (inFlow && invalidFlowScalarChars.includes(ch)) break;\n        end = i;\n      }\n    }\n    if (!ch && !this.atEnd) return this.setNext('plain-scalar');\n    yield SCALAR;\n    yield* this.pushToIndex(end + 1, true);\n    return inFlow ? 'flow' : 'doc';\n  }\n  *pushCount(n) {\n    if (n > 0) {\n      yield this.buffer.substr(this.pos, n);\n      this.pos += n;\n      return n;\n    }\n    return 0;\n  }\n  *pushToIndex(i, allowEmpty) {\n    const s = this.buffer.slice(this.pos, i);\n    if (s) {\n      yield s;\n      this.pos += s.length;\n      return s.length;\n    } else if (allowEmpty) yield '';\n    return 0;\n  }\n  *pushIndicators() {\n    switch (this.charAt(0)) {\n      case '!':\n        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());\n      case '&':\n        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());\n      case '-': // this is an error\n      case '?': // this is an error outside flow collections\n      case ':':\n        {\n          const inFlow = this.flowLevel > 0;\n          const ch1 = this.charAt(1);\n          if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {\n            if (!inFlow) this.indentNext = this.indentValue + 1;else if (this.flowKey) this.flowKey = false;\n            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());\n          }\n        }\n    }\n    return 0;\n  }\n  *pushTag() {\n    if (this.charAt(1) === '<') {\n      let i = this.pos + 2;\n      let ch = this.buffer[i];\n      while (!isEmpty(ch) && ch !== '>') ch = this.buffer[++i];\n      return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n    } else {\n      let i = this.pos + 1;\n      let ch = this.buffer[i];\n      while (ch) {\n        if (tagChars.includes(ch)) ch = this.buffer[++i];else if (ch === '%' && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {\n          ch = this.buffer[i += 3];\n        } else break;\n      }\n      return yield* this.pushToIndex(i, false);\n    }\n  }\n  *pushNewline() {\n    const ch = this.buffer[this.pos];\n    if (ch === '\\n') return yield* this.pushCount(1);else if (ch === '\\r' && this.charAt(1) === '\\n') return yield* this.pushCount(2);else return 0;\n  }\n  *pushSpaces(allowTabs) {\n    let i = this.pos - 1;\n    let ch;\n    do {\n      ch = this.buffer[++i];\n    } while (ch === ' ' || allowTabs && ch === '\\t');\n    const n = i - this.pos;\n    if (n > 0) {\n      yield this.buffer.substr(this.pos, n);\n      this.pos = i;\n    }\n    return n;\n  }\n  *pushUntil(test) {\n    let i = this.pos;\n    let ch = this.buffer[i];\n    while (!test(ch)) ch = this.buffer[++i];\n    return yield* this.pushToIndex(i, false);\n  }\n}\nexport { Lexer };","map":{"version":3,"names":["BOM","DOCUMENT","FLOW_END","SCALAR","isEmpty","ch","undefined","hexDigits","split","tagChars","invalidFlowScalarChars","invalidAnchorChars","isNotAnchorChar","includes","Lexer","constructor","atEnd","blockScalarIndent","blockScalarKeep","buffer","flowKey","flowLevel","indentNext","indentValue","lineEndPos","next","pos","lex","source","incomplete","hasChars","parseNext","atLineEnd","i","charAt","n","continueScalar","offset","indent","dt","substr","getLine","end","indexOf","substring","length","setNext","state","peek","parseStream","parseLineStart","parseBlockStart","parseDocument","parseFlowCollection","parseQuotedScalar","parseBlockScalar","parsePlainScalar","line","pushCount","dirEnd","cs","pushSpaces","pushNewline","sp","s","ch0","ch1","pushIndicators","pushUntil","parseBlockScalarHeader","nl","startsWith","atFlowEndMarker","quote","qb","pushToIndex","Number","loop","lastChar","inFlow","Math","max","allowEmpty","slice","pushTag","allowTabs","test"],"sources":["/workspaces/moorse/node_modules/yaml/browser/dist/parse/lexer.js"],"sourcesContent":["import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nconst invalidFlowScalarChars = ',[]{}'.split('');\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            const cs = line.indexOf('#');\n            if (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd = cs - 1;\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if (s === '---' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return 'doc';\n            }\n            else if (s === '...' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                return 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else\n                this.indentNext += this.blockScalarIndent;\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ' || ch === '\\t')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && next === ','))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && invalidFlowScalarChars.includes(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.includes(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.includes(this.buffer[i + 1]) &&\n                    hexDigits.includes(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexport { Lexer };\n"],"mappings":"AAAA,SAASA,GAAG,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,QAAQ,UAAU;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAO,CAACC,EAAE,EAAE;EACjB,QAAQA,EAAE;IACN,KAAKC,SAAS;IACd,KAAK,GAAG;IACR,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;MACL,OAAO,IAAI;IACf;MACI,OAAO,KAAK;EAAC;AAEzB;AACA,MAAMC,SAAS,GAAG,wBAAwB,CAACC,KAAK,CAAC,EAAE,CAAC;AACpD,MAAMC,QAAQ,GAAG,mFAAmF,CAACD,KAAK,CAAC,EAAE,CAAC;AAC9G,MAAME,sBAAsB,GAAG,OAAO,CAACF,KAAK,CAAC,EAAE,CAAC;AAChD,MAAMG,kBAAkB,GAAG,cAAc,CAACH,KAAK,CAAC,EAAE,CAAC;AACnD,MAAMI,eAAe,GAAIP,EAAE,IAAK,CAACA,EAAE,IAAIM,kBAAkB,CAACE,QAAQ,CAACR,EAAE,CAAC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMS,KAAK,CAAC;EACRC,WAAW,GAAG;IACV;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,KAAK;IAClB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,CAAC,CAAC;IAC3B;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B;IACA,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB;AA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}