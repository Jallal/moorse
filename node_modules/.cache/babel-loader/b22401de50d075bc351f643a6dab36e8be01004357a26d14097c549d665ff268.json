{"ast":null,"code":"import { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { NodeBase, ALIAS, isAlias, isCollection, isPair } from './Node.js';\nclass Alias extends NodeBase {\n  constructor(source) {\n    super(ALIAS);\n    this.source = source;\n    Object.defineProperty(this, 'tag', {\n      set() {\n        throw new Error('Alias nodes cannot have tags');\n      }\n    });\n  }\n  /**\n   * Resolve the value of this alias within `doc`, finding the last\n   * instance of the `source` anchor before this node.\n   */\n  resolve(doc) {\n    let found = undefined;\n    visit(doc, {\n      Node: (_key, node) => {\n        if (node === this) return visit.BREAK;\n        if (node.anchor === this.source) found = node;\n      }\n    });\n    return found;\n  }\n  toJSON(_arg, ctx) {\n    if (!ctx) return {\n      source: this.source\n    };\n    const {\n      anchors,\n      doc,\n      maxAliasCount\n    } = ctx;\n    const source = this.resolve(doc);\n    if (!source) {\n      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n      throw new ReferenceError(msg);\n    }\n    const data = anchors.get(source);\n    /* istanbul ignore if */\n    if (!data || data.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      throw new ReferenceError(msg);\n    }\n    if (maxAliasCount >= 0) {\n      data.count += 1;\n      if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);\n      if (data.count * data.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        throw new ReferenceError(msg);\n      }\n    }\n    return data.res;\n  }\n  toString(ctx, _onComment, _onChompKeep) {\n    const src = `*${this.source}`;\n    if (ctx) {\n      anchorIsValid(this.source);\n      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n        throw new Error(msg);\n      }\n      if (ctx.implicitKey) return `${src} `;\n    }\n    return src;\n  }\n}\nfunction getAliasCount(doc, node, anchors) {\n  if (isAlias(node)) {\n    const source = node.resolve(doc);\n    const anchor = anchors && source && anchors.get(source);\n    return anchor ? anchor.count * anchor.aliasCount : 0;\n  } else if (isCollection(node)) {\n    let count = 0;\n    for (const item of node.items) {\n      const c = getAliasCount(doc, item, anchors);\n      if (c > count) count = c;\n    }\n    return count;\n  } else if (isPair(node)) {\n    const kc = getAliasCount(doc, node.key, anchors);\n    const vc = getAliasCount(doc, node.value, anchors);\n    return Math.max(kc, vc);\n  }\n  return 1;\n}\nexport { Alias };","map":{"version":3,"names":["anchorIsValid","visit","NodeBase","ALIAS","isAlias","isCollection","isPair","Alias","constructor","source","Object","defineProperty","set","Error","resolve","doc","found","undefined","Node","_key","node","BREAK","anchor","toJSON","_arg","ctx","anchors","maxAliasCount","msg","ReferenceError","data","get","res","count","aliasCount","getAliasCount","toString","_onComment","_onChompKeep","src","options","verifyAliasOrder","has","implicitKey","item","items","c","kc","key","vc","value","Math","max"],"sources":["/Users/jhazzatgmail.com/Documents/moorseapp/node_modules/yaml/browser/dist/nodes/Alias.js"],"sourcesContent":["import { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { NodeBase, ALIAS, isAlias, isCollection, isPair } from './Node.js';\n\nclass Alias extends NodeBase {\n    constructor(source) {\n        super(ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        const data = anchors.get(source);\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexport { Alias };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}