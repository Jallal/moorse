{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { ChipListSelectionContext, ChipListFocusContext, ChipListDataContext } from './ChipList';\nimport { classNames, useDir, getTabIndex, Keys, kendoThemeMaps } from '@progress/kendo-react-common';\nimport { FOCUS_ACTION } from './focus-reducer';\nimport { DATA_ACTION } from './data-reducer';\nimport { SELECTION_ACTION } from './selection-reducer';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from '../package-metadata';\nimport { useMouse } from '@progress/kendo-react-common';\n/**\n * Represents the Chip component.\n */\nexport var Chip = React.forwardRef(function (props, ref) {\n  var _a;\n  validatePackage(packageMetadata);\n  var target = React.useRef(null);\n  var chipRef = React.useRef(null);\n  var dir = useDir(chipRef, props.dir);\n  React.useImperativeHandle(target, function () {\n    return {\n      element: chipRef.current,\n      props: props\n    };\n  });\n  React.useImperativeHandle(ref, function () {\n    return target.current;\n  });\n  var _b = React.useContext(ChipListSelectionContext),\n    selection = _b[0],\n    dispatchSelection = _b[1];\n  var _c = React.useContext(ChipListFocusContext),\n    focus = _c[0],\n    dispatchFocus = _c[1];\n  var _d = React.useContext(ChipListDataContext),\n    dispatchData = _d[1];\n  var selected = React.useMemo(function () {\n    return props.selected || (Array.isArray(selection) ? selection.some(function (i) {\n      return i === props.value;\n    }) : selection === props.value);\n  }, [props.selected, props.value, selection]);\n  var focused = React.useMemo(function () {\n    return focus === props.value;\n  }, [props.value, focus]);\n  React.useEffect(function () {\n    if (focused && chipRef.current) {\n      chipRef.current.focus();\n    }\n  }, [focused]);\n  var handleClick = React.useCallback(function (event) {\n    dispatchSelection({\n      type: SELECTION_ACTION.toggle,\n      payload: props.value,\n      event: event\n    });\n  }, [dispatchSelection, props.value]);\n  var handleRemove = React.useCallback(function (event) {\n    if (!props.removable) {\n      return;\n    }\n    dispatchData({\n      type: DATA_ACTION.remove,\n      payload: props.value,\n      event: event\n    });\n    dispatchFocus({\n      type: FOCUS_ACTION.reset,\n      payload: props.value,\n      event: event\n    });\n    dispatchSelection({\n      type: SELECTION_ACTION.remove,\n      payload: props.value,\n      event: event\n    });\n    if (props.onRemove) {\n      props.onRemove.call(undefined, {\n        target: target.current,\n        syntheticEvent: event\n      });\n    }\n  }, [props.onRemove, props.value, props.removable, dispatchData, dispatchFocus, dispatchSelection]);\n  var handleKeyDown = React.useCallback(function (event) {\n    switch (event.keyCode) {\n      case Keys.left:\n        dispatchFocus({\n          type: FOCUS_ACTION.prev,\n          payload: props.value,\n          event: event\n        });\n        break;\n      case Keys.right:\n        dispatchFocus({\n          type: FOCUS_ACTION.next,\n          payload: props.value,\n          event: event\n        });\n        break;\n      case Keys.enter:\n        dispatchSelection({\n          type: SELECTION_ACTION.toggle,\n          payload: props.value,\n          event: event\n        });\n        break;\n      case Keys.delete:\n        handleRemove(event);\n        break;\n      default:\n        break;\n    }\n    if (props.onKeyDown) {\n      props.onKeyDown.call(undefined, {\n        target: target.current,\n        syntheticEvent: event\n      });\n    }\n  }, [props.onKeyDown, props.value, dispatchFocus, dispatchSelection, handleRemove]);\n  var handleFocus = React.useCallback(function (event) {\n    dispatchFocus({\n      payload: props.value,\n      type: FOCUS_ACTION.current,\n      event: event\n    });\n    if (props.onFocus) {\n      props.onFocus.call(undefined, {\n        target: target.current,\n        syntheticEvent: event\n      });\n    }\n  }, [props.onFocus, props.value, dispatchFocus]);\n  var handleBlur = React.useCallback(function (event) {\n    if (props.onBlur) {\n      props.onBlur.call(undefined, {\n        target: target.current,\n        syntheticEvent: event\n      });\n    }\n  }, [props.onBlur]);\n  var mouseProps = useMouse(props, target, {\n    onClick: handleClick\n  });\n  return React.createElement(\"div\", __assign({}, mouseProps, {\n    role: props.role,\n    id: props.value,\n    style: props.style,\n    ref: chipRef,\n    dir: dir,\n    tabIndex: getTabIndex(props.tabIndex, props.disabled, undefined),\n    className: classNames('k-chip', (_a = {\n      'k-rtl': dir === 'rtl',\n      'k-disabled': props.disabled,\n      'k-selected': selected,\n      'k-focus': focused\n    }, _a[\"k-chip-\".concat(kendoThemeMaps.sizeMap[props.size] || props.size)] = props.size, _a[\"k-rounded-\".concat(kendoThemeMaps.roundedMap[props.rounded] || props.rounded)] = props.rounded, _a[\"k-chip-\".concat(props.fillMode)] = props.fillMode, _a[\"k-chip-\".concat(props.fillMode, \"-\").concat(props.themeColor)] = Boolean(props.fillMode && props.themeColor), _a), props.className),\n    \"aria-checked\": selected,\n    \"aria-disabled\": props.disabled,\n    \"aria-describedby\": props.ariaDescribedBy,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown\n  }), selected && props.selectedIcon && React.createElement(\"span\", {\n    className: classNames('k-chip-icon', 'k-icon', props.selectedIcon)\n  }), props.icon && React.createElement(\"span\", {\n    className: classNames('k-chip-icon', 'k-icon', props.icon)\n  }), React.createElement(\"span\", {\n    className: 'k-chip-content'\n  }, props.children !== undefined ? props.children : props.text && React.createElement(\"span\", {\n    \"aria-label\": props.text,\n    className: 'k-chip-label'\n  }, props.text)), props.removable && React.createElement(\"span\", {\n    className: \"k-chip-actions\"\n  }, React.createElement(\"span\", {\n    className: classNames('k-chip-action', 'k-chip-remove-action')\n  }, React.createElement(\"span\", {\n    className: classNames('k-icon', props.removeIcon),\n    onClick: handleRemove\n  }))));\n});\nvar propTypes = {\n  id: PropTypes.string,\n  text: PropTypes.string,\n  value: PropTypes.any,\n  dir: PropTypes.oneOf(['ltr', 'rtl']),\n  removable: PropTypes.bool,\n  removeIcon: PropTypes.string,\n  disabled: PropTypes.bool,\n  icon: PropTypes.string,\n  selectedIcon: PropTypes.string,\n  onRemove: PropTypes.func,\n  dataItem: PropTypes.any,\n  selected: PropTypes.bool,\n  ariaDescribedBy: PropTypes.string,\n  size: PropTypes.oneOf([null, 'small', 'medium', 'large']),\n  rounded: PropTypes.oneOf([null, 'small', 'medium', 'large', 'full']),\n  fillMode: PropTypes.oneOf([null, 'outline', 'solid']),\n  // eslint-disable-next-line max-len\n  themeColor: PropTypes.oneOf([null, 'base', 'info', 'success', 'warning', 'error'])\n};\nvar defaultProps = {\n  disabled: false,\n  removable: false,\n  removeIcon: 'k-i-x-circle',\n  dir: 'ltr',\n  size: 'medium',\n  rounded: 'medium',\n  fillMode: 'solid',\n  themeColor: 'base'\n};\nChip.displayName = 'KendoReactChip';\n// TODO: delete casting when @types/react is updated!\nChip.propTypes = propTypes;\nChip.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}