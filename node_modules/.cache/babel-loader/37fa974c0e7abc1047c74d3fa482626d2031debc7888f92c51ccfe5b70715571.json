{"ast":null,"code":"import { Alias } from '../nodes/Alias.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\nconst CN = {\n  composeNode,\n  composeEmptyNode\n};\nfunction composeNode(ctx, token, props, onError) {\n  const {\n    spaceBefore,\n    comment,\n    anchor,\n    tag\n  } = props;\n  let node;\n  let isSrcToken = true;\n  switch (token.type) {\n    case 'alias':\n      node = composeAlias(ctx, token, onError);\n      if (anchor || tag) onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n      break;\n    case 'scalar':\n    case 'single-quoted-scalar':\n    case 'double-quoted-scalar':\n    case 'block-scalar':\n      node = composeScalar(ctx, token, tag, onError);\n      if (anchor) node.anchor = anchor.source.substring(1);\n      break;\n    case 'block-map':\n    case 'block-seq':\n    case 'flow-collection':\n      node = composeCollection(CN, ctx, token, tag, onError);\n      if (anchor) node.anchor = anchor.source.substring(1);\n      break;\n    default:\n      {\n        const message = token.type === 'error' ? token.message : `Unsupported token (type: ${token.type})`;\n        onError(token, 'UNEXPECTED_TOKEN', message);\n        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n        isSrcToken = false;\n      }\n  }\n  if (anchor && node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n  if (spaceBefore) node.spaceBefore = true;\n  if (comment) {\n    if (token.type === 'scalar' && token.source === '') node.comment = comment;else node.commentBefore = comment;\n  }\n  // @ts-expect-error Type checking misses meaning of isSrcToken\n  if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;\n  return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, _ref, onError) {\n  let {\n    spaceBefore,\n    comment,\n    anchor,\n    tag,\n    end\n  } = _ref;\n  const token = {\n    type: 'scalar',\n    offset: emptyScalarPosition(offset, before, pos),\n    indent: -1,\n    source: ''\n  };\n  const node = composeScalar(ctx, token, tag, onError);\n  if (anchor) {\n    node.anchor = anchor.source.substring(1);\n    if (node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n  }\n  if (spaceBefore) node.spaceBefore = true;\n  if (comment) {\n    node.comment = comment;\n    node.range[2] = end;\n  }\n  return node;\n}\nfunction composeAlias(_ref2, _ref3, onError) {\n  let {\n    options\n  } = _ref2;\n  let {\n    offset,\n    source,\n    end\n  } = _ref3;\n  const alias = new Alias(source.substring(1));\n  if (alias.source === '') onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n  if (alias.source.endsWith(':')) onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n  const valueEnd = offset + source.length;\n  const re = resolveEnd(end, valueEnd, options.strict, onError);\n  alias.range = [offset, valueEnd, re.offset];\n  if (re.comment) alias.comment = re.comment;\n  return alias;\n}\nexport { composeEmptyNode, composeNode };","map":{"version":3,"names":["Alias","composeCollection","composeScalar","resolveEnd","emptyScalarPosition","CN","composeNode","composeEmptyNode","ctx","token","props","onError","spaceBefore","comment","anchor","tag","node","isSrcToken","type","composeAlias","source","substring","message","offset","undefined","commentBefore","options","keepSourceTokens","srcToken","before","pos","end","indent","range","alias","endsWith","length","valueEnd","re","strict"],"sources":["/Users/jhazzatgmail.com/Documents/moorseapp/node_modules/yaml/browser/dist/compose/compose-node.js"],"sourcesContent":["import { Alias } from '../nodes/Alias.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexport { composeEmptyNode, composeNode };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}