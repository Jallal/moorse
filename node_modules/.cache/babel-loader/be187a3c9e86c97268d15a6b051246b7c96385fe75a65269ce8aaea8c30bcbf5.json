{"ast":null,"code":"import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve(src, onError) {\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n      return buffer;\n    } else {\n      onError('This environment does not support reading binary tags; either Buffer or atob is required');\n      return src;\n    }\n  },\n  stringify(_ref, ctx, onComment, onChompKeep) {\n    let {\n      comment,\n      type,\n      value\n    } = _ref;\n    const buf = value; // checked earlier by binary.identify()\n    let str;\n    if (typeof Buffer === 'function') {\n      str = buf instanceof Buffer ? buf.toString('base64') : Buffer.from(buf.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n      for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);\n      str = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n    if (!type) type = Scalar.BLOCK_LITERAL;\n    if (type !== Scalar.QUOTE_DOUBLE) {\n      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n      const n = Math.ceil(str.length / lineWidth);\n      const lines = new Array(n);\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = str.substr(o, lineWidth);\n      }\n      str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n    return stringifyString({\n      comment,\n      type,\n      value: str\n    }, ctx, onComment, onChompKeep);\n  }\n};\nexport { binary };","map":{"version":3,"names":["Scalar","stringifyString","binary","identify","value","Uint8Array","default","tag","resolve","src","onError","Buffer","from","atob","str","replace","buffer","length","i","charCodeAt","stringify","ctx","onComment","onChompKeep","comment","type","buf","toString","btoa","s","String","fromCharCode","Error","BLOCK_LITERAL","QUOTE_DOUBLE","lineWidth","Math","max","options","indent","minContentWidth","n","ceil","lines","Array","o","substr","join"],"sources":["/workspaces/moorse/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"],"sourcesContent":["import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array,\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof Buffer === 'function') {\n            return Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof Buffer === 'function') {\n            str =\n                buf instanceof Buffer\n                    ? buf.toString('base64')\n                    : Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}