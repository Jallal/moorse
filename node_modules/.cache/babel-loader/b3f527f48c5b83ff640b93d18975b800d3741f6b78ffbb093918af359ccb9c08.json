{"ast":null,"code":"import { resolveBlockScalar } from '../compose/resolve-block-scalar.js';\nimport { resolveFlowScalar } from '../compose/resolve-flow-scalar.js';\nimport { YAMLParseError } from '../errors.js';\nimport { stringifyString } from '../stringify/stringifyString.js';\nfunction resolveAsScalar(token) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let onError = arguments.length > 2 ? arguments[2] : undefined;\n  if (token) {\n    const _onError = (pos, code, message) => {\n      const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n      if (onError) onError(offset, code, message);else throw new YAMLParseError([offset, offset + 1], code, message);\n    };\n    switch (token.type) {\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return resolveFlowScalar(token, strict, _onError);\n      case 'block-scalar':\n        return resolveBlockScalar(token, strict, _onError);\n    }\n  }\n  return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n  const {\n    implicitKey = false,\n    indent,\n    inFlow = false,\n    offset = -1,\n    type = 'PLAIN'\n  } = context;\n  const source = stringifyString({\n    type,\n    value\n  }, {\n    implicitKey,\n    indent: indent > 0 ? ' '.repeat(indent) : '',\n    inFlow,\n    options: {\n      blockQuote: true,\n      lineWidth: -1\n    }\n  });\n  const end = context.end ?? [{\n    type: 'newline',\n    offset: -1,\n    indent,\n    source: '\\n'\n  }];\n  switch (source[0]) {\n    case '|':\n    case '>':\n      {\n        const he = source.indexOf('\\n');\n        const head = source.substring(0, he);\n        const body = source.substring(he + 1) + '\\n';\n        const props = [{\n          type: 'block-scalar-header',\n          offset,\n          indent,\n          source: head\n        }];\n        if (!addEndtoBlockProps(props, end)) props.push({\n          type: 'newline',\n          offset: -1,\n          indent,\n          source: '\\n'\n        });\n        return {\n          type: 'block-scalar',\n          offset,\n          indent,\n          props,\n          source: body\n        };\n      }\n    case '\"':\n      return {\n        type: 'double-quoted-scalar',\n        offset,\n        indent,\n        source,\n        end\n      };\n    case \"'\":\n      return {\n        type: 'single-quoted-scalar',\n        offset,\n        indent,\n        source,\n        end\n      };\n    default:\n      return {\n        type: 'scalar',\n        offset,\n        indent,\n        source,\n        end\n      };\n  }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value) {\n  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let {\n    afterKey = false,\n    implicitKey = false,\n    inFlow = false,\n    type\n  } = context;\n  let indent = 'indent' in token ? token.indent : null;\n  if (afterKey && typeof indent === 'number') indent += 2;\n  if (!type) switch (token.type) {\n    case 'single-quoted-scalar':\n      type = 'QUOTE_SINGLE';\n      break;\n    case 'double-quoted-scalar':\n      type = 'QUOTE_DOUBLE';\n      break;\n    case 'block-scalar':\n      {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');\n        type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n        break;\n      }\n    default:\n      type = 'PLAIN';\n  }\n  const source = stringifyString({\n    type,\n    value\n  }, {\n    implicitKey: implicitKey || indent === null,\n    indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n    inFlow,\n    options: {\n      blockQuote: true,\n      lineWidth: -1\n    }\n  });\n  switch (source[0]) {\n    case '|':\n    case '>':\n      setBlockScalarValue(token, source);\n      break;\n    case '\"':\n      setFlowScalarValue(token, source, 'double-quoted-scalar');\n      break;\n    case \"'\":\n      setFlowScalarValue(token, source, 'single-quoted-scalar');\n      break;\n    default:\n      setFlowScalarValue(token, source, 'scalar');\n  }\n}\nfunction setBlockScalarValue(token, source) {\n  const he = source.indexOf('\\n');\n  const head = source.substring(0, he);\n  const body = source.substring(he + 1) + '\\n';\n  if (token.type === 'block-scalar') {\n    const header = token.props[0];\n    if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');\n    header.source = head;\n    token.source = body;\n  } else {\n    const {\n      offset\n    } = token;\n    const indent = 'indent' in token ? token.indent : -1;\n    const props = [{\n      type: 'block-scalar-header',\n      offset,\n      indent,\n      source: head\n    }];\n    if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined)) props.push({\n      type: 'newline',\n      offset: -1,\n      indent,\n      source: '\\n'\n    });\n    for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];\n    Object.assign(token, {\n      type: 'block-scalar',\n      indent,\n      props,\n      source: body\n    });\n  }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n  if (end) for (const st of end) switch (st.type) {\n    case 'space':\n    case 'comment':\n      props.push(st);\n      break;\n    case 'newline':\n      props.push(st);\n      return true;\n  }\n  return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n  switch (token.type) {\n    case 'scalar':\n    case 'double-quoted-scalar':\n    case 'single-quoted-scalar':\n      token.type = type;\n      token.source = source;\n      break;\n    case 'block-scalar':\n      {\n        const end = token.props.slice(1);\n        let oa = source.length;\n        if (token.props[0].type === 'block-scalar-header') oa -= token.props[0].source.length;\n        for (const tok of end) tok.offset += oa;\n        delete token.props;\n        Object.assign(token, {\n          type,\n          source,\n          end\n        });\n        break;\n      }\n    case 'block-map':\n    case 'block-seq':\n      {\n        const offset = token.offset + source.length;\n        const nl = {\n          type: 'newline',\n          offset,\n          indent: token.indent,\n          source: '\\n'\n        };\n        delete token.items;\n        Object.assign(token, {\n          type,\n          source,\n          end: [nl]\n        });\n        break;\n      }\n    default:\n      {\n        const indent = 'indent' in token ? token.indent : -1;\n        const end = 'end' in token && Array.isArray(token.end) ? token.end.filter(st => st.type === 'space' || st.type === 'comment' || st.type === 'newline') : [];\n        for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];\n        Object.assign(token, {\n          type,\n          indent,\n          source,\n          end\n        });\n      }\n  }\n}\nexport { createScalarToken, resolveAsScalar, setScalarValue };","map":{"version":3,"names":["resolveBlockScalar","resolveFlowScalar","YAMLParseError","stringifyString","resolveAsScalar","token","strict","onError","_onError","pos","code","message","offset","Array","isArray","type","createScalarToken","value","context","implicitKey","indent","inFlow","source","repeat","options","blockQuote","lineWidth","end","he","indexOf","head","substring","body","props","addEndtoBlockProps","push","setScalarValue","afterKey","header","Error","setBlockScalarValue","setFlowScalarValue","undefined","key","Object","keys","assign","st","slice","oa","length","tok","nl","items","filter"],"sources":["/workspaces/moorse/node_modules/yaml/browser/dist/parse/cst-scalar.js"],"sourcesContent":["import { resolveBlockScalar } from '../compose/resolve-block-scalar.js';\nimport { resolveFlowScalar } from '../compose/resolve-flow-scalar.js';\nimport { YAMLParseError } from '../errors.js';\nimport { stringifyString } from '../stringify/stringifyString.js';\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar(token, strict, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexport { createScalarToken, resolveAsScalar, setScalarValue };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}