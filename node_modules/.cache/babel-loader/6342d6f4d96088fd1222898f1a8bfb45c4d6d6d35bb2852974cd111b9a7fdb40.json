{"ast":null,"code":"import { isCollection, isNode, isScalar, isSeq } from '../nodes/Node.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\nfunction stringifyPair(_ref, ctx, onComment, onChompKeep) {\n  let {\n    key,\n    value\n  } = _ref;\n  const {\n    allNullValues,\n    doc,\n    indent,\n    indentStep,\n    options: {\n      commentString,\n      indentSeq,\n      simpleKeys\n    }\n  } = ctx;\n  let keyComment = isNode(key) && key.comment || null;\n  if (simpleKeys) {\n    if (keyComment) {\n      throw new Error('With simple keys, key nodes cannot have comments');\n    }\n    if (isCollection(key)) {\n      const msg = 'With simple keys, collection cannot be used as a key value';\n      throw new Error(msg);\n    }\n  }\n  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === 'object'));\n  ctx = Object.assign({}, ctx, {\n    allNullValues: false,\n    implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n    indent: indent + indentStep\n  });\n  let keyCommentDone = false;\n  let chompKeep = false;\n  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);\n  if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n    if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n    explicitKey = true;\n  }\n  if (ctx.inFlow) {\n    if (allNullValues || value == null) {\n      if (keyCommentDone && onComment) onComment();\n      return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n    }\n  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {\n    str = `? ${str}`;\n    if (keyComment && !keyCommentDone) {\n      str += lineComment(str, ctx.indent, commentString(keyComment));\n    } else if (chompKeep && onChompKeep) onChompKeep();\n    return str;\n  }\n  if (keyCommentDone) keyComment = null;\n  if (explicitKey) {\n    if (keyComment) str += lineComment(str, ctx.indent, commentString(keyComment));\n    str = `? ${str}\\n${indent}:`;\n  } else {\n    str = `${str}:`;\n    if (keyComment) str += lineComment(str, ctx.indent, commentString(keyComment));\n  }\n  let vsb, vcb, valueComment;\n  if (isNode(value)) {\n    vsb = !!value.spaceBefore;\n    vcb = value.commentBefore;\n    valueComment = value.comment;\n  } else {\n    vsb = false;\n    vcb = null;\n    valueComment = null;\n    if (value && typeof value === 'object') value = doc.createNode(value);\n  }\n  ctx.implicitKey = false;\n  if (!explicitKey && !keyComment && isScalar(value)) ctx.indentAtStart = str.length + 1;\n  chompKeep = false;\n  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {\n    // If indentSeq === false, consider '- ' as part of indentation where possible\n    ctx.indent = ctx.indent.substring(2);\n  }\n  let valueCommentDone = false;\n  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);\n  let ws = ' ';\n  if (keyComment || vsb || vcb) {\n    ws = vsb ? '\\n' : '';\n    if (vcb) {\n      const cs = commentString(vcb);\n      ws += `\\n${indentComment(cs, ctx.indent)}`;\n    }\n    if (valueStr === '' && !ctx.inFlow) {\n      if (ws === '\\n') ws = '\\n\\n';\n    } else {\n      ws += `\\n${ctx.indent}`;\n    }\n  } else if (!explicitKey && isCollection(value)) {\n    const vs0 = valueStr[0];\n    const nl0 = valueStr.indexOf('\\n');\n    const hasNewline = nl0 !== -1;\n    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n    if (hasNewline || !flow) {\n      let hasPropsLine = false;\n      if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n        let sp0 = valueStr.indexOf(' ');\n        if (vs0 === '&' && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === '!') {\n          sp0 = valueStr.indexOf(' ', sp0 + 1);\n        }\n        if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;\n      }\n      if (!hasPropsLine) ws = `\\n${ctx.indent}`;\n    }\n  } else if (valueStr === '' || valueStr[0] === '\\n') {\n    ws = '';\n  }\n  str += ws + valueStr;\n  if (ctx.inFlow) {\n    if (valueCommentDone && onComment) onComment();\n  } else if (valueComment && !valueCommentDone) {\n    str += lineComment(str, ctx.indent, commentString(valueComment));\n  } else if (chompKeep && onChompKeep) {\n    onChompKeep();\n  }\n  return str;\n}\nexport { stringifyPair };","map":{"version":3,"names":["isCollection","isNode","isScalar","isSeq","Scalar","stringify","lineComment","indentComment","stringifyPair","ctx","onComment","onChompKeep","key","value","allNullValues","doc","indent","indentStep","options","commentString","indentSeq","simpleKeys","keyComment","comment","Error","msg","explicitKey","inFlow","type","BLOCK_FOLDED","BLOCK_LITERAL","Object","assign","implicitKey","keyCommentDone","chompKeep","str","length","vsb","vcb","valueComment","spaceBefore","commentBefore","createNode","indentAtStart","flow","tag","anchor","substring","valueCommentDone","valueStr","ws","cs","vs0","nl0","indexOf","hasNewline","items","hasPropsLine","sp0"],"sources":["/Users/jhazzatgmail.com/Documents/moorseapp/node_modules/yaml/browser/dist/stringify/stringifyPair.js"],"sourcesContent":["import { isCollection, isNode, isScalar, isSeq } from '../nodes/Node.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (isCollection(key)) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            isCollection(key) ||\n            (isScalar(key)\n                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexport { stringifyPair };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}